============================================================
PULL REQUEST FEEDBACK COMPLETO
============================================================

PULL REQUEST #10: Dev
============================================================

DESCRIPCIN:
------------------------------------------------------------



COMENTARIOS EN LA CONVERSACIN:
------------------------------------------------------------
 @gemini-code-assist (2025-11-01T08:41:35Z):
## Summary of Changes

Hello @carlostoek, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

Este Pull Request introduce un robusto y completo Sistema de Experiencias Unificadas, dise帽ado para integrar diversos elementos del sistema en flujos cohesivos de usuario. Esto permite la creaci贸n de experiencias estructuradas con requisitos previos complejos y recompensas combinadas. La implementaci贸n abarca la definici贸n de un nuevo esquema de base de datos, la creaci贸n de modelos SQLAlchemy correspondientes y el desarrollo de la l贸gica central para gestionar el inicio, el progreso y la finalizaci贸n de estas experiencias, as铆 como la validaci贸n de sus requisitos. Adem谩s, se han realizado ajustes menores en la serializaci贸n de datos de modelos existentes y se ha actualizado la documentaci贸n interna para reflejar el avance del proyecto.

### Highlights

* **Nuevo Sistema de Experiencias Unificadas**: Se ha introducido un sistema completo para gestionar experiencias de usuario, como misiones o cadenas narrativas, con componentes, requisitos y recompensas.
* **Actualizaci贸n de la Base de Datos**: Se han a帽adido nuevas tablas a la base de datos para soportar el sistema de experiencias, incluyendo `experiences`, `experience_components`, `user_experience_progress`, `user_component_completions`, `experience_requirements` y `experience_rewards`.
* **L贸gica Central de Experiencias**: Se han implementado un motor (`ExperienceEngine`) y un validador (`CompositeValidator`) para manejar el ciclo de vida de las experiencias, desde su inicio y progreso hasta su finalizaci贸n, incluyendo la validaci贸n de requisitos complejos.
* **Mejoras en la Serializaci贸n de Modelos**: Se han actualizado varios m茅todos `to_dict` en los modelos de Python existentes para manejar de forma m谩s robusta los valores `None` antes de la serializaci贸n.
* **Actualizaci贸n de Documentaci贸n Interna**: Se han modificado las instrucciones para los agentes y el seguimiento de fases del proyecto, marcando la 'Fase 4 (M贸dulo de Experiencias Unificadas)' como completada y avanzando a la Fase 5.







<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point by creating a comment using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands on the current page.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in pull request comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

------------------------------------------------------------


REVIEWS GENERALES:
------------------------------------------------------------
 @gemini-code-assist [COMMENTED] (2025-11-01T08:43:40Z):
## Code Review

This pull request introduces a new 'experiences' module, which is a significant feature addition. It also includes several bug fixes in `to_dict` methods by using `is not None` checks, which improves correctness. However, the review identified several critical and high-severity issues that need to be addressed. There are critical database connection leaks in the new `ExperienceEngine` and `CompositeValidator` classes. A high-severity bug was found in the calculation of average completion time. Furthermore, the new test file `test_experiences_engine.py` contains multiple critical flaws, including tests for non-existent methods and incorrect mocking, which means the new logic is not being properly tested. There are also several medium-severity issues related to code consistency, use of deprecated functions, and placeholder implementations.
------------------------------------------------------------


COMENTARIOS EN ARCHIVOS ESPECFICOS:
============================================================

 ARCHIVO: AGENTS.md
============================================================
   L铆nea 34 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

There are a couple of typos in this section that should be corrected for clarity.

- On line 30, 'face' should be 'fase'.
- On line 34, there is a trailing 'j' in 'fasesj'.

```suggestion
   - Al t茅rmino de la fase te enviar茅  una revisi贸n en donde posiblemente se encuentren algunos detalles que tendr谩s que corregir
3. **Estructura de Fases**:
   - Las fases est谩n divididas por archivos en `docs/fases_evoluci贸n/`
   - Cada archivo contiene el detalle espec铆fico de lo que se necesita implementar Y en la parte inferior los apartados completos del documento de investigaci贸n a los que hace referencia cada fase para que los puedas consultar directamente ah铆 sin tener que leer todo el documento de investigaci贸n
   - El orden num茅rico de los archivos indica la secuencia de fases
```
  
  C贸digo:
  ```
  @@ -23,14 +25,13 @@ You are responsible for implementing a single, specific task from a specificatio
      - Realizar un commit resumiendo lo implementado en esa fase
      - Hacer push a remoto
      - Marcar la fase como completada en `TODO_EVOLUTION.md` agregando una l铆nea: "Fase X completada"
  -   - Pasar autom谩ticamente a la siguiente fase sin solicitar confirmaci贸n
      - Real铆za tests con datos reales utiliza mocks 煤nicamente con servicios que no dependan de nosotros
      - Si hay problemas con los test no simplifiques el test verifica cu谩l es el error y solucionarlo para poder ejecutar tu test
  -
  +   - Al t茅rmino de la face te enviar茅  una revisi贸n en donde posiblemente se encuentren algunos detalles que tendr谩s que corregir
   3. **Estructura de Fases**:
      - Las fases est谩n divididas por archivos en `docs/fases_evoluci贸n/`
      - Cada archivo contiene el detalle espec铆fico de lo que se necesita implementar Y en la parte inferior los apartados completos del documento de investigaci贸n a los que hace referencia cada fase para que los puedas consultar directamente ah铆 sin tener que leer todo el documento de investigaci贸n
  -   - El orden num茅rico de los archivos indica la secuencia de fases
  +   - El orden num茅rico de los archivos indica la secuencia de fasesj
  ```
  ----------------------------------------------------------

 ARCHIVO: database/models.py
============================================================
   L铆nea 1382 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

While you've correctly updated existing `to_dict` methods to use `is not None` for checking optional fields, the new models you've added still use the old `hasattr(self.field, 'isoformat')` pattern. For consistency across the codebase, please update the `to_dict` methods in all the new `Experience` related models to use the `is not None` check.

```suggestion
            "created_at": self.created_at.isoformat() if self.created_at is not None else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at is not None else None
```
  
  C贸digo:
  ```
  @@ -1315,7 +1315,295 @@ def to_dict(self):
               "expires_at": self.expires_at.isoformat() if hasattr(self.expires_at, 'isoformat') else None,
               "is_active": self.is_active,
               "viewed": self.viewed,
  -            "viewed_at": self.viewed_at.isoformat() if self.viewed_at else None,
  +            "viewed_at": self.viewed_at.isoformat() if self.viewed_at is not None else None,
               "accepted": self.accepted,
  -            "accepted_at": self.accepted_at.isoformat() if self.accepted_at else None
  +            "accepted_at": self.accepted_at.isoformat() if self.accepted_at is not None else None
  +        }
  +
  +
  +class Experience(Base):
  +    """Experience model for unified experiences system"""
  +    __tablename__ = "experiences"
  +    
  +    id = Column(Integer, primary_key=True, index=True)
  +    experience_key = Column(String(100), unique=True, nullable=False, index=True)
  +    name = Column(String(255), nullable=False)
  +    description = Column(Text, nullable=True)
  +    experience_type = Column(String(50), nullable=False)  # 'narrative_chain', 'mission_chain', 'event_chain', 'mixed'
  +    
  +    # Configuraci贸n
  +    is_active = Column(Boolean, default=True)
  +    is_visible = Column(Boolean, default=True)
  +    difficulty_level = Column(String(50), default='normal')  # 'easy', 'normal', 'hard', 'expert'
  +    estimated_duration = Column(Integer, nullable=True)  # en minutos
  +    
  +    # M茅tricas
  +    start_count = Column(Integer, default=0)
  +    completion_count = Column(Integer, default=0)
  +    average_completion_time = Column(Float, default=0.0)  # en minutos
  +    success_rate = Column(Float, default=0.0)  # porcentaje
  +    
  +    # Metadata
  +    tags = Column(ARRAY(String), nullable=True)
  +    experience_metadata = Column(JSON, nullable=True)
  +    
  +    # Timestamps
  +    created_at = Column(DateTime(timezone=True), server_default=func.now())
  +    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
  +    
  +    # Relationships
  +    components = relationship("ExperienceComponent", back_populates="experience", cascade="all, delete-orphan")
  +    requirements = relationship("ExperienceRequirement", back_populates="experience", cascade="all, delete-orphan")
  +    rewards = relationship("ExperienceReward", back_populates="experience", cascade="all, delete-orphan")
  +    user_progress = relationship("UserExperienceProgress", back_populates="experience", cascade="all, delete-orphan")
  +
  +    def __repr__(self):
  +        return f"<Experience(experience_key={self.experience_key}, name={self.name}, type={self.experience_type})>"
  +
  +    def to_dict(self):
  +        """Convert experience to dictionary"""
  +        return {
  +            "id": self.id,
  +            "experience_key": self.experience_key,
  +            "name": self.name,
  +            "description": self.description,
  +            "experience_type": self.experience_type,
  +            "is_active": self.is_active,
  +            "is_visible": self.is_visible,
  +            "difficulty_level": self.difficulty_level,
  +            "estimated_duration": self.estimated_duration,
  +            "start_count": self.start_count,
  +            "completion_count": self.completion_count,
  +            "average_completion_time": self.average_completion_time,
  +            "success_rate": self.success_rate,
  +            "tags": self.tags,
  +            "metadata": self.experience_metadata,
  +            "created_at": self.created_at.isoformat() if hasattr(self.created_at, 'isoformat') else None,
  +            "updated_at": self.updated_at.isoformat() if hasattr(self.updated_at, 'isoformat') else None
  ```
  ----------------------------------------------------------

 ARCHIVO: modules/experiences/engine.py
============================================================
   L铆nea 25 | @gemini-code-assist[bot]:
   ![critical](https://www.gstatic.com/codereviewagent/critical.svg)

This line will cause database connection leaks. `get_db()` is a generator that yields a database session and is expected to be used as a dependency in a request-response cycle (like in FastAPI), which ensures the session is closed properly. Calling `next(get_db())` gets a session but never closes it. Over time, this will exhaust the database connection pool.

Instead of initializing `self.db` in the constructor, you should acquire a session within each method that needs database access, or pass the session as an argument.
  
  C贸digo:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este m贸dulo implementa el motor central para gestionar experiencias que integran
  +m煤ltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  ```
  ----------------------------------------------------------
   L铆nea 85 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

The `datetime.utcnow()` function is deprecated as of Python 3.12 and will be removed in a future version. It's recommended to use the timezone-aware `datetime.now(timezone.utc)` instead. You'll need to import `timezone` from the `datetime` module.

```suggestion
                started_at=datetime.now(timezone.utc),
```
  
  C贸digo:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este m贸dulo implementa el motor central para gestionar experiencias que integran
  +m煤ltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def start_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Iniciar una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operaci贸n
  +        """
  +        try:
  +            # Validar requisitos compuestos
  +            can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +            if not can_start:
  +                return {
  +                    'success': False,
  +                    'error': 'requirements_not_met',
  +                    'missing_requirements': missing_reqs
  +                }
  +            
  +            # Verificar si ya existe progreso
  +            existing_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if existing_progress:
  +                if existing_progress.status == 'completed':
  +                    return {
  +                        'success': False,
  +                        'error': 'experience_already_completed'
  +                    }
  +                elif existing_progress.status == 'in_progress':
  +                    return {
  +                        'success': True,
  +                        'status': 'resumed',
  +                        'progress': existing_progress
  +                    }
  +            
  +            # Obtener primer componente
  +            first_component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.experience_id == experience_id,
  +                ExperienceComponent.sequence_order == 1
  +            ).first()
  +            
  +            if not first_component:
  +                return {
  +                    'success': False,
  +                    'error': 'no_components_found'
  +                }
  +            
  +            # Crear progreso de usuario
  +            user_progress = UserExperienceProgress(
  +                user_id=user_id,
  +                experience_id=experience_id,
  +                status='in_progress',
  +                current_component_id=first_component.id,
  +                started_at=datetime.utcnow(),
  ```
  ----------------------------------------------------------
   L铆nea 273 | @gemini-code-assist[bot]:
   ![high](https://www.gstatic.com/codereviewagent/high-priority.svg)

The formula used to calculate the new `average_completion_time` is incorrect for a running average. This implementation will heavily skew the average towards the most recent completion time.

The correct way to calculate a new running average is:
`new_avg = ((old_avg * (n-1)) + new_value) / n`

Where `n` is the new total number of completions.

```suggestion
                if user_progress.started_at and user_progress.completed_at:
                    completion_time = (user_progress.completed_at - user_progress.started_at).total_seconds() / 60
                    total_completions = experience.completion_count
                    if total_completions == 1:
                        experience.average_completion_time = completion_time
                    else:
                        old_total_time = experience.average_completion_time * (total_completions - 1)
                        new_total_time = old_total_time + completion_time
                        experience.average_completion_time = new_total_time / total_completions
```
  
  C贸digo:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este m贸dulo implementa el motor central para gestionar experiencias que integran
  +m煤ltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def start_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Iniciar una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operaci贸n
  +        """
  +        try:
  +            # Validar requisitos compuestos
  +            can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +            if not can_start:
  +                return {
  +                    'success': False,
  +                    'error': 'requirements_not_met',
  +                    'missing_requirements': missing_reqs
  +                }
  +            
  +            # Verificar si ya existe progreso
  +            existing_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if existing_progress:
  +                if existing_progress.status == 'completed':
  +                    return {
  +                        'success': False,
  +                        'error': 'experience_already_completed'
  +                    }
  +                elif existing_progress.status == 'in_progress':
  +                    return {
  +                        'success': True,
  +                        'status': 'resumed',
  +                        'progress': existing_progress
  +                    }
  +            
  +            # Obtener primer componente
  +            first_component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.experience_id == experience_id,
  +                ExperienceComponent.sequence_order == 1
  +            ).first()
  +            
  +            if not first_component:
  +                return {
  +                    'success': False,
  +                    'error': 'no_components_found'
  +                }
  +            
  +            # Crear progreso de usuario
  +            user_progress = UserExperienceProgress(
  +                user_id=user_id,
  +                experience_id=experience_id,
  +                status='in_progress',
  +                current_component_id=first_component.id,
  +                started_at=datetime.utcnow(),
  +                last_activity_at=datetime.utcnow(),
  +                completion_percentage=0.0,
  +                components_completed=0,
  +                components_total=self._get_total_components(experience_id)
  +            )
  +            
  +            self.db.add(user_progress)
  +            self.db.commit()
  +            
  +            # Actualizar contador de inicios
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.start_count += 1
  +                self.db.commit()
  +            
  +            logger.info(f"Experiencia {experience_id} iniciada para usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'status': 'started',
  +                'progress': user_progress,
  +                'current_component': first_component
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al iniciar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def progress_experience(self, user_id: int, experience_id: int, component_id: int, 
  +                          completion_data: Optional[Dict] = None) -> Dict[str, Any]:
  +        """
  +        Progresar en una experiencia marcando un componente como completado
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            component_id: ID del componente completado
  +            completion_data: Datos adicionales de completitud
  +            
  +        Returns:
  +            Dict con resultado de la operaci贸n
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress or user_progress.status != 'in_progress':
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_in_progress'
  +                }
  +            
  +            # Verificar que el componente es el actual o est谩 disponible
  +            component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.id == component_id
  +            ).first()
  +            
  +            if not component:
  +                return {
  +                    'success': False,
  +                    'error': 'component_not_found'
  +                }
  +            
  +            # Verificar si ya est谩 completado
  +            existing_completion = self.db.query(UserComponentCompletion).filter(
  +                UserComponentCompletion.user_progress_id == user_progress.id,
  +                UserComponentCompletion.component_id == component_id
  +            ).first()
  +            
  +            if existing_completion:
  +                return {
  +                    'success': False,
  +                    'error': 'component_already_completed'
  +                }
  +            
  +            # Registrar completitud del componente
  +            component_completion = UserComponentCompletion(
  +                user_progress_id=user_progress.id,
  +                component_id=component_id,
  +                completed_at=datetime.utcnow(),
  +                completion_data=completion_data or {}
  +            )
  +            
  +            self.db.add(component_completion)
  +            
  +            # Actualizar progreso
  +            user_progress.components_completed += 1
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Calcular porcentaje de completitud
  +            total_components = user_progress.components_total
  +            if total_components > 0:
  +                user_progress.completion_percentage = (user_progress.components_completed / total_components) * 100
  +            
  +            # Otorgar recompensas del componente
  +            if component.completion_rewards:
  +                self._grant_component_rewards(user_id, component.completion_rewards)
  +            
  +            # Determinar siguiente componente
  +            next_component = self._get_next_component(experience_id, component.sequence_order)
  +            if next_component:
  +                user_progress.current_component_id = next_component.id
  +            else:
  +                # No hay m谩s componentes, completar experiencia
  +                return self.complete_experience(user_id, experience_id)
  +            
  +            self.db.commit()
  +            
  +            logger.info(f"Componente {component_id} completado en experiencia {experience_id} por usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'component_completed': component,
  +                'next_component': next_component,
  +                'progress': user_progress
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al progresar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def complete_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Completar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operaci贸n
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress:
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_found'
  +                }
  +            
  +            # Actualizar progreso
  +            user_progress.status = 'completed'
  +            user_progress.completed_at = datetime.utcnow()
  +            user_progress.completion_percentage = 100.0
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Otorgar recompensas finales
  +            experience_rewards = self.db.query(ExperienceReward).filter(
  +                ExperienceReward.experience_id == experience_id
  +            ).all()
  +            
  +            rewards_granted = []
  +            for reward in experience_rewards:
  +                reward_result = self._grant_experience_reward(user_id, reward)
  +                rewards_granted.append({
  +                    'reward': reward,
  +                    'result': reward_result
  +                })
  +            
  +            # Actualizar contador de completitudes
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.completion_count += 1
  +                # Calcular tiempo promedio de completitud
  +                if user_progress.started_at and user_progress.completed_at:
  +                    completion_time = (user_progress.completed_at - user_progress.started_at).total_seconds() / 60
  +                    if experience.average_completion_time == 0:
  +                        experience.average_completion_time = completion_time
  +                    else:
  +                        experience.average_completion_time = (
  +                            experience.average_completion_time + completion_time
  +                        ) / 2
  ```
  ----------------------------------------------------------
   L铆nea 383 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

This method, along with `_grant_component_rewards` and `_grant_experience_reward`, contains placeholder logic with a `TODO` comment. These should be implemented to provide the actual functionality for checking requirements and granting rewards.
  
  C贸digo:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este m贸dulo implementa el motor central para gestionar experiencias que integran
  +m煤ltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def start_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Iniciar una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operaci贸n
  +        """
  +        try:
  +            # Validar requisitos compuestos
  +            can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +            if not can_start:
  +                return {
  +                    'success': False,
  +                    'error': 'requirements_not_met',
  +                    'missing_requirements': missing_reqs
  +                }
  +            
  +            # Verificar si ya existe progreso
  +            existing_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if existing_progress:
  +                if existing_progress.status == 'completed':
  +                    return {
  +                        'success': False,
  +                        'error': 'experience_already_completed'
  +                    }
  +                elif existing_progress.status == 'in_progress':
  +                    return {
  +                        'success': True,
  +                        'status': 'resumed',
  +                        'progress': existing_progress
  +                    }
  +            
  +            # Obtener primer componente
  +            first_component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.experience_id == experience_id,
  +                ExperienceComponent.sequence_order == 1
  +            ).first()
  +            
  +            if not first_component:
  +                return {
  +                    'success': False,
  +                    'error': 'no_components_found'
  +                }
  +            
  +            # Crear progreso de usuario
  +            user_progress = UserExperienceProgress(
  +                user_id=user_id,
  +                experience_id=experience_id,
  +                status='in_progress',
  +                current_component_id=first_component.id,
  +                started_at=datetime.utcnow(),
  +                last_activity_at=datetime.utcnow(),
  +                completion_percentage=0.0,
  +                components_completed=0,
  +                components_total=self._get_total_components(experience_id)
  +            )
  +            
  +            self.db.add(user_progress)
  +            self.db.commit()
  +            
  +            # Actualizar contador de inicios
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.start_count += 1
  +                self.db.commit()
  +            
  +            logger.info(f"Experiencia {experience_id} iniciada para usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'status': 'started',
  +                'progress': user_progress,
  +                'current_component': first_component
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al iniciar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def progress_experience(self, user_id: int, experience_id: int, component_id: int, 
  +                          completion_data: Optional[Dict] = None) -> Dict[str, Any]:
  +        """
  +        Progresar en una experiencia marcando un componente como completado
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            component_id: ID del componente completado
  +            completion_data: Datos adicionales de completitud
  +            
  +        Returns:
  +            Dict con resultado de la operaci贸n
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress or user_progress.status != 'in_progress':
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_in_progress'
  +                }
  +            
  +            # Verificar que el componente es el actual o est谩 disponible
  +            component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.id == component_id
  +            ).first()
  +            
  +            if not component:
  +                return {
  +                    'success': False,
  +                    'error': 'component_not_found'
  +                }
  +            
  +            # Verificar si ya est谩 completado
  +            existing_completion = self.db.query(UserComponentCompletion).filter(
  +                UserComponentCompletion.user_progress_id == user_progress.id,
  +                UserComponentCompletion.component_id == component_id
  +            ).first()
  +            
  +            if existing_completion:
  +                return {
  +                    'success': False,
  +                    'error': 'component_already_completed'
  +                }
  +            
  +            # Registrar completitud del componente
  +            component_completion = UserComponentCompletion(
  +                user_progress_id=user_progress.id,
  +                component_id=component_id,
  +                completed_at=datetime.utcnow(),
  +                completion_data=completion_data or {}
  +            )
  +            
  +            self.db.add(component_completion)
  +            
  +            # Actualizar progreso
  +            user_progress.components_completed += 1
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Calcular porcentaje de completitud
  +            total_components = user_progress.components_total
  +            if total_components > 0:
  +                user_progress.completion_percentage = (user_progress.components_completed / total_components) * 100
  +            
  +            # Otorgar recompensas del componente
  +            if component.completion_rewards:
  +                self._grant_component_rewards(user_id, component.completion_rewards)
  +            
  +            # Determinar siguiente componente
  +            next_component = self._get_next_component(experience_id, component.sequence_order)
  +            if next_component:
  +                user_progress.current_component_id = next_component.id
  +            else:
  +                # No hay m谩s componentes, completar experiencia
  +                return self.complete_experience(user_id, experience_id)
  +            
  +            self.db.commit()
  +            
  +            logger.info(f"Componente {component_id} completado en experiencia {experience_id} por usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'component_completed': component,
  +                'next_component': next_component,
  +                'progress': user_progress
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al progresar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def complete_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Completar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operaci贸n
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress:
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_found'
  +                }
  +            
  +            # Actualizar progreso
  +            user_progress.status = 'completed'
  +            user_progress.completed_at = datetime.utcnow()
  +            user_progress.completion_percentage = 100.0
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Otorgar recompensas finales
  +            experience_rewards = self.db.query(ExperienceReward).filter(
  +                ExperienceReward.experience_id == experience_id
  +            ).all()
  +            
  +            rewards_granted = []
  +            for reward in experience_rewards:
  +                reward_result = self._grant_experience_reward(user_id, reward)
  +                rewards_granted.append({
  +                    'reward': reward,
  +                    'result': reward_result
  +                })
  +            
  +            # Actualizar contador de completitudes
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.completion_count += 1
  +                # Calcular tiempo promedio de completitud
  +                if user_progress.started_at and user_progress.completed_at:
  +                    completion_time = (user_progress.completed_at - user_progress.started_at).total_seconds() / 60
  +                    if experience.average_completion_time == 0:
  +                        experience.average_completion_time = completion_time
  +                    else:
  +                        experience.average_completion_time = (
  +                            experience.average_completion_time + completion_time
  +                        ) / 2
  +            
  +            self.db.commit()
  +            
  +            logger.info(f"Experiencia {experience_id} completada por usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'progress': user_progress,
  +                'rewards_granted': rewards_granted
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al completar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def get_experience_status(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Obtener estado actual de una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con estado de la experiencia
  +        """
  +        try:
  +            # Obtener progreso del usuario
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            # Obtener experiencia
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            
  +            if not experience:
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_found'
  +                }
  +            
  +            # Si no hay progreso, verificar requisitos
  +            if not user_progress:
  +                can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +                return {
  +                    'success': True,
  +                    'status': 'not_started',
  +                    'can_start': can_start,
  +                    'missing_requirements': missing_reqs,
  +                    'experience': experience
  +                }
  +            
  +            # Obtener componentes completados
  +            completed_components = self.db.query(UserComponentCompletion).filter(
  +                UserComponentCompletion.user_progress_id == user_progress.id
  +            ).all()
  +            
  +            # Obtener componente actual
  +            current_component = None
  +            if user_progress.current_component_id:
  +                current_component = self.db.query(ExperienceComponent).filter(
  +                    ExperienceComponent.id == user_progress.current_component_id
  +                ).first()
  +            
  +            return {
  +                'success': True,
  +                'status': user_progress.status,
  +                'progress': user_progress,
  +                'current_component': current_component,
  +                'completed_components': completed_components,
  +                'experience': experience
  +            }
  +            
  +        except Exception as e:
  +            logger.error(f"Error al obtener estado de experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def _validate_requirements(self, user_id: int, experience_id: int) -> tuple[bool, List[Dict]]:
  +        """Validar requisitos compuestos para iniciar experiencia"""
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        all_met = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_requirement(user_id, req)
  +            if not is_met:
  +                all_met = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return all_met, missing_requirements
  +    
  +    def _check_requirement(self, user_id: int, requirement: ExperienceRequirement) -> tuple[bool, Dict]:
  +        """Verificar un requisito espec铆fico"""
  +        # TODO: Implementar validaci贸n espec铆fica por tipo de requisito
  +        # Por ahora retornamos True para todos los requisitos
  +        return True, {}
  ```
  ----------------------------------------------------------

 ARCHIVO: modules/experiences/validator.py
============================================================
   L铆nea 24 | @gemini-code-assist[bot]:
   ![critical](https://www.gstatic.com/codereviewagent/critical.svg)

This line will cause database connection leaks. `get_db()` is a generator that yields a database session and is expected to be used as a dependency in a request-response cycle (like in FastAPI), which ensures the session is closed properly. Calling `next(get_db())` gets a session but never closes it. Over time, this will exhaust the database connection pool.

Instead of initializing `self.db` in the constructor, you should acquire a session within each method that needs database access, or pass the session as an argument.
  
  C贸digo:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este m贸dulo implementa la validaci贸n de requisitos que integran m煤ltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  ```
  ----------------------------------------------------------
   L铆nea 140 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

The methods `_validate_single_requirement` and `_check_experience_requirement` are nearly identical. This code duplication can lead to maintenance issues where a change in one method is not reflected in the other. Consider refactoring to remove the duplication. For example, `_check_experience_requirement` could be adapted to call `_validate_single_requirement`.
  
  C贸digo:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este m贸dulo implementa la validaci贸n de requisitos que integran m煤ltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def validate_composite_requirements(self, user_id: int, requirements: List[Dict]) -> Dict[str, Any]:
  +        """
  +        Validar m煤ltiples requisitos de diferentes sistemas
  +        
  +        Args:
  +            user_id: ID del usuario
  +            requirements: Lista de requisitos a validar
  +            
  +        Returns:
  +            Dict con resultado de validaci贸n
  +        """
  +        validation_results = []
  +        all_valid = True
  +        
  +        for req in requirements:
  +            is_valid, details = self._validate_single_requirement(user_id, req)
  +            validation_results.append({
  +                'requirement': req,
  +                'is_valid': is_valid,
  +                'details': details
  +            })
  +            
  +            if not is_valid:
  +                all_valid = False
  +        
  +        return {
  +            'all_valid': all_valid,
  +            'validation_results': validation_results
  +        }
  +    
  +    def can_start_experience(self, user_id: int, experience_id: int) -> Tuple[bool, List[Dict]]:
  +        """
  +        Verificar si un usuario puede iniciar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Tuple (puede_iniciar, requisitos_faltantes)
  +        """
  +        # Obtener requisitos de la experiencia
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        can_start = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_experience_requirement(user_id, req)
  +            if not is_met:
  +                can_start = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return can_start, missing_requirements
  +    
  +    def get_missing_requirements(self, user_id: int, experience_id: int) -> List[Dict]:
  +        """
  +        Obtener lista detallada de requisitos faltantes
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Lista de requisitos faltantes con detalles
  +        """
  +        _, missing_reqs = self.can_start_experience(user_id, experience_id)
  +        return missing_reqs
  +    
  +    def _validate_single_requirement(self, user_id: int, requirement: Dict) -> Tuple[bool, Dict]:
  +        """Validar un requisito individual"""
  +        req_type = requirement.get('type')
  +        req_value = requirement.get('value', {})
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _check_experience_requirement(self, user_id: int, requirement: ExperienceRequirement) -> Tuple[bool, Dict]:
  +        """Verificar un requisito de experiencia espec铆fico"""
  +        req_type = requirement.requirement_type
  +        req_value = requirement.requirement_value
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  ```
  ----------------------------------------------------------
   L铆nea 148 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

This method contains placeholder logic with a `TODO` comment and assumes a hardcoded `user_level`. This should be implemented to fetch the actual user level to correctly validate the requirement.
  
  C贸digo:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este m贸dulo implementa la validaci贸n de requisitos que integran m煤ltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def validate_composite_requirements(self, user_id: int, requirements: List[Dict]) -> Dict[str, Any]:
  +        """
  +        Validar m煤ltiples requisitos de diferentes sistemas
  +        
  +        Args:
  +            user_id: ID del usuario
  +            requirements: Lista de requisitos a validar
  +            
  +        Returns:
  +            Dict con resultado de validaci贸n
  +        """
  +        validation_results = []
  +        all_valid = True
  +        
  +        for req in requirements:
  +            is_valid, details = self._validate_single_requirement(user_id, req)
  +            validation_results.append({
  +                'requirement': req,
  +                'is_valid': is_valid,
  +                'details': details
  +            })
  +            
  +            if not is_valid:
  +                all_valid = False
  +        
  +        return {
  +            'all_valid': all_valid,
  +            'validation_results': validation_results
  +        }
  +    
  +    def can_start_experience(self, user_id: int, experience_id: int) -> Tuple[bool, List[Dict]]:
  +        """
  +        Verificar si un usuario puede iniciar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Tuple (puede_iniciar, requisitos_faltantes)
  +        """
  +        # Obtener requisitos de la experiencia
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        can_start = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_experience_requirement(user_id, req)
  +            if not is_met:
  +                can_start = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return can_start, missing_requirements
  +    
  +    def get_missing_requirements(self, user_id: int, experience_id: int) -> List[Dict]:
  +        """
  +        Obtener lista detallada de requisitos faltantes
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Lista de requisitos faltantes con detalles
  +        """
  +        _, missing_reqs = self.can_start_experience(user_id, experience_id)
  +        return missing_reqs
  +    
  +    def _validate_single_requirement(self, user_id: int, requirement: Dict) -> Tuple[bool, Dict]:
  +        """Validar un requisito individual"""
  +        req_type = requirement.get('type')
  +        req_value = requirement.get('value', {})
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _check_experience_requirement(self, user_id: int, requirement: ExperienceRequirement) -> Tuple[bool, Dict]:
  +        """Verificar un requisito de experiencia espec铆fico"""
  +        req_type = requirement.requirement_type
  +        req_value = requirement.requirement_value
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _validate_level_requirement(self, user_id: int, requirement_value: Dict) -> Tuple[bool, Dict]:
  +        """Validar requisito de nivel"""
  +        min_level = requirement_value.get('min_level', 1)
  +        
  +        # TODO: Implementar sistema de niveles
  +        # Por ahora asumimos nivel 1 para todos los usuarios
  +        user_level = 1
  ```
  ----------------------------------------------------------
   L铆nea 169 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

Using `== True` for boolean comparisons is not idiomatic in Python. It's more concise and conventional to check the truthiness of the value directly.

```suggestion
            VIPSubscription.is_active
```
  
  C贸digo:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este m贸dulo implementa la validaci贸n de requisitos que integran m煤ltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def validate_composite_requirements(self, user_id: int, requirements: List[Dict]) -> Dict[str, Any]:
  +        """
  +        Validar m煤ltiples requisitos de diferentes sistemas
  +        
  +        Args:
  +            user_id: ID del usuario
  +            requirements: Lista de requisitos a validar
  +            
  +        Returns:
  +            Dict con resultado de validaci贸n
  +        """
  +        validation_results = []
  +        all_valid = True
  +        
  +        for req in requirements:
  +            is_valid, details = self._validate_single_requirement(user_id, req)
  +            validation_results.append({
  +                'requirement': req,
  +                'is_valid': is_valid,
  +                'details': details
  +            })
  +            
  +            if not is_valid:
  +                all_valid = False
  +        
  +        return {
  +            'all_valid': all_valid,
  +            'validation_results': validation_results
  +        }
  +    
  +    def can_start_experience(self, user_id: int, experience_id: int) -> Tuple[bool, List[Dict]]:
  +        """
  +        Verificar si un usuario puede iniciar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Tuple (puede_iniciar, requisitos_faltantes)
  +        """
  +        # Obtener requisitos de la experiencia
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        can_start = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_experience_requirement(user_id, req)
  +            if not is_met:
  +                can_start = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return can_start, missing_requirements
  +    
  +    def get_missing_requirements(self, user_id: int, experience_id: int) -> List[Dict]:
  +        """
  +        Obtener lista detallada de requisitos faltantes
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Lista de requisitos faltantes con detalles
  +        """
  +        _, missing_reqs = self.can_start_experience(user_id, experience_id)
  +        return missing_reqs
  +    
  +    def _validate_single_requirement(self, user_id: int, requirement: Dict) -> Tuple[bool, Dict]:
  +        """Validar un requisito individual"""
  +        req_type = requirement.get('type')
  +        req_value = requirement.get('value', {})
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _check_experience_requirement(self, user_id: int, requirement: ExperienceRequirement) -> Tuple[bool, Dict]:
  +        """Verificar un requisito de experiencia espec铆fico"""
  +        req_type = requirement.requirement_type
  +        req_value = requirement.requirement_value
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _validate_level_requirement(self, user_id: int, requirement_value: Dict) -> Tuple[bool, Dict]:
  +        """Validar requisito de nivel"""
  +        min_level = requirement_value.get('min_level', 1)
  +        
  +        # TODO: Implementar sistema de niveles
  +        # Por ahora asumimos nivel 1 para todos los usuarios
  +        user_level = 1
  +        
  +        is_met = user_level >= min_level
  +        details = {
  +            'required_level': min_level,
  +            'current_level': user_level,
  +            'missing_levels': max(0, min_level - user_level)
  +        }
  +        
  +        return is_met, details
  +    
  +    def _validate_vip_requirement(self, user_id: int, requirement_value: Dict) -> Tuple[bool, Dict]:
  +        """Validar requisito de membres铆a VIP"""
  +        required = requirement_value.get('required', False)
  +        
  +        if not required:
  +            return True, {'vip_required': False}
  +        
  +        # Verificar suscripci贸n VIP activa
  +        vip_subscription = self.db.query(VIPSubscription).filter(
  +            VIPSubscription.user_id == user_id,
  +            VIPSubscription.is_active == True
  ```
  ----------------------------------------------------------

 ARCHIVO: test_experiences_engine.py
============================================================
   L铆nea 12 | @gemini-code-assist[bot]:
   ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

Modifying `sys.path` at runtime is generally considered a code smell. It can make tests less predictable and dependent on the execution context. It would be better to configure your test runner (like `pytest`) to correctly discover modules by setting the `PYTHONPATH` or using a proper package structure with `__init__.py` files.
  
  C贸digo:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  ```
  ----------------------------------------------------------
   L铆nea 85 | @gemini-code-assist[bot]:
   ![high](https://www.gstatic.com/codereviewagent/high-priority.svg)

This test is not correctly testing the `can_start_experience` method. You are patching `validate_composite_requirements`, but `can_start_experience` does not call this method. It calls `_check_experience_requirement`. As a result, this test passes without actually validating the intended logic. You should patch `_check_experience_requirement` instead.
  
  C贸digo:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  +
  +# Import experiences modules
  +from modules.experiences.engine import ExperienceEngine
  +from modules.experiences.validator import CompositeValidator
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +
  +class TestCompositeValidator:
  +    """Tests para CompositeValidator"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.validator = CompositeValidator()
  +        self.validator.db = self.mock_db
  +    
  +    def test_validate_composite_requirements_success(self):
  +        """Test que validaci贸n de requisitos compuestos funciona correctamente"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 3},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones individuales exitosas
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.return_value = (True, {'message': 'Requirement met'})
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is True
  +            assert len(result['validation_results']) == 3
  +            for validation in result['validation_results']:
  +                assert validation['is_valid'] is True
  +    
  +    def test_validate_composite_requirements_failure(self):
  +        """Test que validaci贸n falla cuando faltan requisitos"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 5},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones mixtas (algunas fallan)
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.side_effect = [
  +                (False, {'message': 'Level too low'}),
  +                (True, {'message': 'VIP requirement met'}),
  +                (False, {'message': 'Not enough besitos'})
  +            ]
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is False
  +            assert len(result['validation_results']) == 3
  +            assert result['validation_results'][0]['is_valid'] is False
  +            assert result['validation_results'][1]['is_valid'] is True
  +            assert result['validation_results'][2]['is_valid'] is False
  +    
  +    def test_can_start_experience_success(self):
  +        """Test que verifica si usuario puede iniciar experiencia exitosamente"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  ```
  ----------------------------------------------------------
   L铆nea 147 | @gemini-code-assist[bot]:
   ![high](https://www.gstatic.com/codereviewagent/high-priority.svg)

This assertion is incorrect. The `start_experience` method in `ExperienceEngine` calls `self.db.commit()` twice under successful conditions (once after adding `user_progress`, and once after updating `experience.start_count`). This test will fail. The assertion should be changed to `assert_has_calls` or the number of expected calls should be corrected.

```suggestion
            self.mock_db.commit.call_count == 2
```
  
  C贸digo:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  +
  +# Import experiences modules
  +from modules.experiences.engine import ExperienceEngine
  +from modules.experiences.validator import CompositeValidator
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +
  +class TestCompositeValidator:
  +    """Tests para CompositeValidator"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.validator = CompositeValidator()
  +        self.validator.db = self.mock_db
  +    
  +    def test_validate_composite_requirements_success(self):
  +        """Test que validaci贸n de requisitos compuestos funciona correctamente"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 3},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones individuales exitosas
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.return_value = (True, {'message': 'Requirement met'})
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is True
  +            assert len(result['validation_results']) == 3
  +            for validation in result['validation_results']:
  +                assert validation['is_valid'] is True
  +    
  +    def test_validate_composite_requirements_failure(self):
  +        """Test que validaci贸n falla cuando faltan requisitos"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 5},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones mixtas (algunas fallan)
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.side_effect = [
  +                (False, {'message': 'Level too low'}),
  +                (True, {'message': 'VIP requirement met'}),
  +                (False, {'message': 'Not enough besitos'})
  +            ]
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is False
  +            assert len(result['validation_results']) == 3
  +            assert result['validation_results'][0]['is_valid'] is False
  +            assert result['validation_results'][1]['is_valid'] is True
  +            assert result['validation_results'][2]['is_valid'] is False
  +    
  +    def test_can_start_experience_success(self):
  +        """Test que verifica si usuario puede iniciar experiencia exitosamente"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {'all_valid': True, 'validation_results': []}
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is True
  +            assert len(missing_reqs) == 0
  +    
  +    def test_can_start_experience_failure(self):
  +        """Test que verifica si usuario NO puede iniciar experiencia"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {
  +                'all_valid': False, 
  +                'validation_results': [
  +                    {'requirement': {'type': 'level'}, 'is_valid': False, 'details': {'message': 'Level too low'}}
  +                ]
  +            }
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is False
  +            assert len(missing_reqs) == 1
  +            assert missing_reqs[0]['type'] == 'level'
  +
  +
  +class TestExperienceEngine:
  +    """Tests para ExperienceEngine"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.engine = ExperienceEngine()
  +        self.engine.db = self.mock_db
  +    
  +    def test_start_experience_success(self):
  +        """Test que se puede iniciar una experiencia exitosamente"""
  +        # Mock de validaci贸n exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de que no existe progreso previo
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = None
  +            
  +            # Mock de primer componente
  +            mock_component = Mock()
  +            mock_component.id = 1
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_component
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is True
  +            assert result['status'] == 'started'
  +            assert 'progress' in result
  +            
  +            # Verificar que se guard贸 en la base de datos
  +            self.mock_db.add.assert_called_once()
  +            self.mock_db.commit.assert_called_once()
  ```
  ----------------------------------------------------------
   L铆nea 280 | @gemini-code-assist[bot]:
   ![critical](https://www.gstatic.com/codereviewagent/critical.svg)

These tests (`test_complete_component_success` and `test_complete_component_final_component`) are attempting to test a method named `complete_component` which does not exist in the `ExperienceEngine` class. The method for advancing an experience is `progress_experience`. These tests need to be rewritten to target the correct method and use the appropriate arguments and mocks. As they are, they provide no test coverage for the progression logic.
  
  C贸digo:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  +
  +# Import experiences modules
  +from modules.experiences.engine import ExperienceEngine
  +from modules.experiences.validator import CompositeValidator
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +
  +class TestCompositeValidator:
  +    """Tests para CompositeValidator"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.validator = CompositeValidator()
  +        self.validator.db = self.mock_db
  +    
  +    def test_validate_composite_requirements_success(self):
  +        """Test que validaci贸n de requisitos compuestos funciona correctamente"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 3},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones individuales exitosas
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.return_value = (True, {'message': 'Requirement met'})
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is True
  +            assert len(result['validation_results']) == 3
  +            for validation in result['validation_results']:
  +                assert validation['is_valid'] is True
  +    
  +    def test_validate_composite_requirements_failure(self):
  +        """Test que validaci贸n falla cuando faltan requisitos"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 5},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones mixtas (algunas fallan)
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.side_effect = [
  +                (False, {'message': 'Level too low'}),
  +                (True, {'message': 'VIP requirement met'}),
  +                (False, {'message': 'Not enough besitos'})
  +            ]
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is False
  +            assert len(result['validation_results']) == 3
  +            assert result['validation_results'][0]['is_valid'] is False
  +            assert result['validation_results'][1]['is_valid'] is True
  +            assert result['validation_results'][2]['is_valid'] is False
  +    
  +    def test_can_start_experience_success(self):
  +        """Test que verifica si usuario puede iniciar experiencia exitosamente"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {'all_valid': True, 'validation_results': []}
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is True
  +            assert len(missing_reqs) == 0
  +    
  +    def test_can_start_experience_failure(self):
  +        """Test que verifica si usuario NO puede iniciar experiencia"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {
  +                'all_valid': False, 
  +                'validation_results': [
  +                    {'requirement': {'type': 'level'}, 'is_valid': False, 'details': {'message': 'Level too low'}}
  +                ]
  +            }
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is False
  +            assert len(missing_reqs) == 1
  +            assert missing_reqs[0]['type'] == 'level'
  +
  +
  +class TestExperienceEngine:
  +    """Tests para ExperienceEngine"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.engine = ExperienceEngine()
  +        self.engine.db = self.mock_db
  +    
  +    def test_start_experience_success(self):
  +        """Test que se puede iniciar una experiencia exitosamente"""
  +        # Mock de validaci贸n exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de que no existe progreso previo
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = None
  +            
  +            # Mock de primer componente
  +            mock_component = Mock()
  +            mock_component.id = 1
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_component
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is True
  +            assert result['status'] == 'started'
  +            assert 'progress' in result
  +            
  +            # Verificar que se guard贸 en la base de datos
  +            self.mock_db.add.assert_called_once()
  +            self.mock_db.commit.assert_called_once()
  +    
  +    def test_start_experience_requirements_failed(self):
  +        """Test que no se puede iniciar experiencia sin requisitos"""
  +        # Mock de validaci贸n fallida
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (False, ['level_5'])
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is False
  +            assert result['error'] == 'requirements_not_met'
  +            assert 'level_5' in result['missing_requirements']
  +            
  +            # Verificar que NO se guard贸 en la base de datos
  +            self.mock_db.add.assert_not_called()
  +            self.mock_db.commit.assert_not_called()
  +    
  +    def test_start_experience_already_completed(self):
  +        """Test que no se puede reiniciar experiencia completada"""
  +        # Mock de validaci贸n exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de progreso ya completado
  +            mock_progress = Mock()
  +            mock_progress.status = 'completed'
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_progress
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is False
  +            assert result['error'] == 'experience_already_completed'
  +    
  +    def test_start_experience_resume(self):
  +        """Test que se puede reanudar experiencia en progreso"""
  +        # Mock de validaci贸n exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de progreso en progreso
  +            mock_progress = Mock()
  +            mock_progress.status = 'in_progress'
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_progress
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is True
  +            assert result['status'] == 'resumed'
  +            assert result['progress'] == mock_progress
  +    
  +    def test_complete_component_success(self):
  +        """Test que se puede completar un componente"""
  +        # Mock de progreso
  +        mock_progress = Mock()
  +        mock_progress.user_id = 1
  +        mock_progress.experience_id = 1
  +        mock_progress.components_completed = 0
  +        mock_progress.components_total = 3
  +        mock_progress.completion_percentage = 0.0
  +        
  +        # Mock de componente
  +        mock_component = Mock()
  +        mock_component.id = 1
  +        mock_component.sequence_order = 1
  +        mock_component.completion_rewards = {'besitos': 25}
  +        
  +        # Mock de experiencia
  +        mock_experience = Mock()
  +        mock_experience.components = [mock_component, Mock(), Mock()]
  +        
  +        # Mock de siguiente componente
  +        with patch.object(self.engine, '_get_next_component') as mock_next:
  +            mock_next.return_value = Mock()
  +            
  +            result = self.engine.complete_component(mock_progress, mock_component, mock_experience)
  +            
  +            assert result['success'] is True
  +            assert 'completion' in result
  +            assert 'rewards_granted' in result
  +            assert result['rewards_granted']['besitos'] == 25
  +            
  +            # Verificar que se actualiz贸 el progreso
  +            assert mock_progress.components_completed == 1
  +            assert mock_progress.completion_percentage == 33.33
  +            assert mock_progress.last_activity_at is not None
  +            
  +            # Verificar que se guard贸 en la base de datos
  +            self.mock_db.add.assert_called_once()
  +            self.mock_db.commit.assert_called_once()
  +    
  +    def test_complete_component_final_component(self):
  +        """Test que completar 煤ltimo componente completa la experiencia"""
  +        # Mock de progreso
  +        mock_progress = Mock()
  +        mock_progress.user_id = 1
  +        mock_progress.experience_id = 1
  +        mock_progress.components_completed = 2
  +        mock_progress.components_total = 3
  +        mock_progress.completion_percentage = 66.67
  +        
  +        # Mock de componente
  +        mock_component = Mock()
  +        mock_component.id = 3
  +        mock_component.sequence_order = 3
  +        mock_component.completion_rewards = {'besitos': 50}
  +        
  +        # Mock de experiencia
  +        mock_experience = Mock()
  +        mock_experience.id = 1
  +        mock_experience.completion_count = 0
  +        mock_experience.rewards = [Mock(reward_type='besitos', reward_value={'amount': 100})]
  +        
  +        # Mock de que no hay siguiente componente
  +        with patch.object(self.engine, '_get_next_component') as mock_next:
  +            mock_next.return_value = None
  +            
  +            # Mock de recompensas de experiencia
  +            with patch.object(self.engine, '_grant_experience_rewards') as mock_grant:
  +                mock_grant.return_value = {'besitos': 100}
  +                
  +                result = self.engine.complete_component(mock_progress, mock_component, mock_experience)
  +                
  +                assert result['success'] is True
  +                assert 'experience_completed' in result
  +                assert result['experience_completed'] is True
  +                
  +                # Verificar que se actualiz贸 el progreso a completado
  +                assert mock_progress.status == 'completed'
  +                assert mock_progress.completed_at is not None
  +                
  +                # Verificar que se actualiz贸 la experiencia
  +                assert mock_experience.completion_count == 1
  +
  ```
  ----------------------------------------------------------


============================================================
RESUMEN:
------------------------------------------------------------
   Comentarios en conversaci贸n: 1
  猸 Reviews generales: 1
   Comentarios en c贸digo: 14
============================================================
