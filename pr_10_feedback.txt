============================================================
PULL REQUEST FEEDBACK COMPLETO
============================================================

PULL REQUEST #10: Dev
============================================================

DESCRIPCIÓN:
------------------------------------------------------------



COMENTARIOS EN LA CONVERSACIÓN:
------------------------------------------------------------
👤 @gemini-code-assist (2025-11-01T08:41:35Z):
## Summary of Changes

Hello @carlostoek, I'm Gemini Code Assist[^1]! I'm currently reviewing this pull request and will post my feedback shortly. In the meantime, here's a summary to help you and other reviewers quickly get up to speed!

Este Pull Request introduce un robusto y completo Sistema de Experiencias Unificadas, diseñado para integrar diversos elementos del sistema en flujos cohesivos de usuario. Esto permite la creación de experiencias estructuradas con requisitos previos complejos y recompensas combinadas. La implementación abarca la definición de un nuevo esquema de base de datos, la creación de modelos SQLAlchemy correspondientes y el desarrollo de la lógica central para gestionar el inicio, el progreso y la finalización de estas experiencias, así como la validación de sus requisitos. Además, se han realizado ajustes menores en la serialización de datos de modelos existentes y se ha actualizado la documentación interna para reflejar el avance del proyecto.

### Highlights

* **Nuevo Sistema de Experiencias Unificadas**: Se ha introducido un sistema completo para gestionar experiencias de usuario, como misiones o cadenas narrativas, con componentes, requisitos y recompensas.
* **Actualización de la Base de Datos**: Se han añadido nuevas tablas a la base de datos para soportar el sistema de experiencias, incluyendo `experiences`, `experience_components`, `user_experience_progress`, `user_component_completions`, `experience_requirements` y `experience_rewards`.
* **Lógica Central de Experiencias**: Se han implementado un motor (`ExperienceEngine`) y un validador (`CompositeValidator`) para manejar el ciclo de vida de las experiencias, desde su inicio y progreso hasta su finalización, incluyendo la validación de requisitos complejos.
* **Mejoras en la Serialización de Modelos**: Se han actualizado varios métodos `to_dict` en los modelos de Python existentes para manejar de forma más robusta los valores `None` antes de la serialización.
* **Actualización de Documentación Interna**: Se han modificado las instrucciones para los agentes y el seguimiento de fases del proyecto, marcando la 'Fase 4 (Módulo de Experiencias Unificadas)' como completada y avanzando a la Fase 5.







<details>
<summary><b>Using Gemini Code Assist</b></summary>
<br>

The full guide for Gemini Code Assist can be found on our [documentation page](https://developers.google.com/gemini-code-assist/docs/review-github-code), here are some quick tips.

<b>Invoking Gemini</b>

You can request assistance from Gemini at any point by creating a comment using either `/gemini <command>` or `@gemini-code-assist <command>`. Below is a summary of the supported commands on the current page.

Feature | Command | Description
--- | --- | ---
Code Review | `/gemini review` | Performs a code review for the current pull request in its current state.
Pull Request Summary | `/gemini summary` | Provides a summary of the current pull request in its current state.
Comment | @gemini-code-assist | Responds in comments when explicitly tagged, both in pull request comments and review comments.
Help | `/gemini help` | Displays a list of available commands.

<b>Customization</b>

To customize Gemini Code Assist for GitHub experience, repository maintainers can create a configuration file and/or provide a custom code review style guide (such as PEP-8 for Python) by creating and adding files to a `.gemini/` folder in the base of the repository. Detailed instructions can be found [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github).

<b>Limitations & Feedback</b>

Gemini Code Assist may make mistakes. Please leave feedback on any instances where its feedback is incorrect or counter productive. You can react with :thumbsup: and :thumbsdown: on @gemini-code-assist comments. If you're interested in giving your feedback about your experience with Gemini Code Assist for Github and other Google products, sign up [here](https://google.qualtrics.com/jfe/form/SV_2cyuGuTWsEw84yG).

<b>You can also get AI-powered code generation, chat, as well as code reviews directly in the IDE at no cost with the [Gemini Code Assist IDE Extension](https://cloud.google.com/products/gemini/code-assist).</b>
</details>




[^1]: Review the [Privacy Notices](https://policies.google.com/privacy), [Generative AI Prohibited Use Policy](https://policies.google.com/terms/generative-ai/use-policy), [Terms of Service](https://policies.google.com/terms), and learn how to configure Gemini Code Assist in GitHub [here](https://developers.google.com/gemini-code-assist/docs/customize-gemini-behavior-github). Gemini can make mistakes, so double check it and [use code with caution](https://support.google.com/legal/answer/13505487).

------------------------------------------------------------


REVIEWS GENERALES:
------------------------------------------------------------
👤 @gemini-code-assist [COMMENTED] (2025-11-01T08:43:40Z):
## Code Review

This pull request introduces a new 'experiences' module, which is a significant feature addition. It also includes several bug fixes in `to_dict` methods by using `is not None` checks, which improves correctness. However, the review identified several critical and high-severity issues that need to be addressed. There are critical database connection leaks in the new `ExperienceEngine` and `CompositeValidator` classes. A high-severity bug was found in the calculation of average completion time. Furthermore, the new test file `test_experiences_engine.py` contains multiple critical flaws, including tests for non-existent methods and incorrect mocking, which means the new logic is not being properly tested. There are also several medium-severity issues related to code consistency, use of deprecated functions, and placeholder implementations.
------------------------------------------------------------


COMENTARIOS EN ARCHIVOS ESPECÍFICOS:
============================================================

📄 ARCHIVO: AGENTS.md
============================================================
  📍 Línea 34 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

There are a couple of typos in this section that should be corrected for clarity.

- On line 30, 'face' should be 'fase'.
- On line 34, there is a trailing 'j' in 'fasesj'.

```suggestion
   - Al término de la fase te enviaré  una revisión en donde posiblemente se encuentren algunos detalles que tendrás que corregir
3. **Estructura de Fases**:
   - Las fases están divididas por archivos en `docs/fases_evolución/`
   - Cada archivo contiene el detalle específico de lo que se necesita implementar Y en la parte inferior los apartados completos del documento de investigación a los que hace referencia cada fase para que los puedas consultar directamente ahí sin tener que leer todo el documento de investigación
   - El orden numérico de los archivos indica la secuencia de fases
```
  
  Código:
  ```
  @@ -23,14 +25,13 @@ You are responsible for implementing a single, specific task from a specificatio
      - Realizar un commit resumiendo lo implementado en esa fase
      - Hacer push a remoto
      - Marcar la fase como completada en `TODO_EVOLUTION.md` agregando una línea: "Fase X completada"
  -   - Pasar automáticamente a la siguiente fase sin solicitar confirmación
      - Realíza tests con datos reales utiliza mocks únicamente con servicios que no dependan de nosotros
      - Si hay problemas con los test no simplifiques el test verifica cuál es el error y solucionarlo para poder ejecutar tu test
  -
  +   - Al término de la face te enviaré  una revisión en donde posiblemente se encuentren algunos detalles que tendrás que corregir
   3. **Estructura de Fases**:
      - Las fases están divididas por archivos en `docs/fases_evolución/`
      - Cada archivo contiene el detalle específico de lo que se necesita implementar Y en la parte inferior los apartados completos del documento de investigación a los que hace referencia cada fase para que los puedas consultar directamente ahí sin tener que leer todo el documento de investigación
  -   - El orden numérico de los archivos indica la secuencia de fases
  +   - El orden numérico de los archivos indica la secuencia de fasesj
  ```
  ----------------------------------------------------------

📄 ARCHIVO: database/models.py
============================================================
  📍 Línea 1382 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

While you've correctly updated existing `to_dict` methods to use `is not None` for checking optional fields, the new models you've added still use the old `hasattr(self.field, 'isoformat')` pattern. For consistency across the codebase, please update the `to_dict` methods in all the new `Experience` related models to use the `is not None` check.

```suggestion
            "created_at": self.created_at.isoformat() if self.created_at is not None else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at is not None else None
```
  
  Código:
  ```
  @@ -1315,7 +1315,295 @@ def to_dict(self):
               "expires_at": self.expires_at.isoformat() if hasattr(self.expires_at, 'isoformat') else None,
               "is_active": self.is_active,
               "viewed": self.viewed,
  -            "viewed_at": self.viewed_at.isoformat() if self.viewed_at else None,
  +            "viewed_at": self.viewed_at.isoformat() if self.viewed_at is not None else None,
               "accepted": self.accepted,
  -            "accepted_at": self.accepted_at.isoformat() if self.accepted_at else None
  +            "accepted_at": self.accepted_at.isoformat() if self.accepted_at is not None else None
  +        }
  +
  +
  +class Experience(Base):
  +    """Experience model for unified experiences system"""
  +    __tablename__ = "experiences"
  +    
  +    id = Column(Integer, primary_key=True, index=True)
  +    experience_key = Column(String(100), unique=True, nullable=False, index=True)
  +    name = Column(String(255), nullable=False)
  +    description = Column(Text, nullable=True)
  +    experience_type = Column(String(50), nullable=False)  # 'narrative_chain', 'mission_chain', 'event_chain', 'mixed'
  +    
  +    # Configuración
  +    is_active = Column(Boolean, default=True)
  +    is_visible = Column(Boolean, default=True)
  +    difficulty_level = Column(String(50), default='normal')  # 'easy', 'normal', 'hard', 'expert'
  +    estimated_duration = Column(Integer, nullable=True)  # en minutos
  +    
  +    # Métricas
  +    start_count = Column(Integer, default=0)
  +    completion_count = Column(Integer, default=0)
  +    average_completion_time = Column(Float, default=0.0)  # en minutos
  +    success_rate = Column(Float, default=0.0)  # porcentaje
  +    
  +    # Metadata
  +    tags = Column(ARRAY(String), nullable=True)
  +    experience_metadata = Column(JSON, nullable=True)
  +    
  +    # Timestamps
  +    created_at = Column(DateTime(timezone=True), server_default=func.now())
  +    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
  +    
  +    # Relationships
  +    components = relationship("ExperienceComponent", back_populates="experience", cascade="all, delete-orphan")
  +    requirements = relationship("ExperienceRequirement", back_populates="experience", cascade="all, delete-orphan")
  +    rewards = relationship("ExperienceReward", back_populates="experience", cascade="all, delete-orphan")
  +    user_progress = relationship("UserExperienceProgress", back_populates="experience", cascade="all, delete-orphan")
  +
  +    def __repr__(self):
  +        return f"<Experience(experience_key={self.experience_key}, name={self.name}, type={self.experience_type})>"
  +
  +    def to_dict(self):
  +        """Convert experience to dictionary"""
  +        return {
  +            "id": self.id,
  +            "experience_key": self.experience_key,
  +            "name": self.name,
  +            "description": self.description,
  +            "experience_type": self.experience_type,
  +            "is_active": self.is_active,
  +            "is_visible": self.is_visible,
  +            "difficulty_level": self.difficulty_level,
  +            "estimated_duration": self.estimated_duration,
  +            "start_count": self.start_count,
  +            "completion_count": self.completion_count,
  +            "average_completion_time": self.average_completion_time,
  +            "success_rate": self.success_rate,
  +            "tags": self.tags,
  +            "metadata": self.experience_metadata,
  +            "created_at": self.created_at.isoformat() if hasattr(self.created_at, 'isoformat') else None,
  +            "updated_at": self.updated_at.isoformat() if hasattr(self.updated_at, 'isoformat') else None
  ```
  ----------------------------------------------------------

📄 ARCHIVO: modules/experiences/engine.py
============================================================
  📍 Línea 25 | @gemini-code-assist[bot]:
  💬 ![critical](https://www.gstatic.com/codereviewagent/critical.svg)

This line will cause database connection leaks. `get_db()` is a generator that yields a database session and is expected to be used as a dependency in a request-response cycle (like in FastAPI), which ensures the session is closed properly. Calling `next(get_db())` gets a session but never closes it. Over time, this will exhaust the database connection pool.

Instead of initializing `self.db` in the constructor, you should acquire a session within each method that needs database access, or pass the session as an argument.
  
  Código:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este módulo implementa el motor central para gestionar experiencias que integran
  +múltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  ```
  ----------------------------------------------------------
  📍 Línea 85 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

The `datetime.utcnow()` function is deprecated as of Python 3.12 and will be removed in a future version. It's recommended to use the timezone-aware `datetime.now(timezone.utc)` instead. You'll need to import `timezone` from the `datetime` module.

```suggestion
                started_at=datetime.now(timezone.utc),
```
  
  Código:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este módulo implementa el motor central para gestionar experiencias que integran
  +múltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def start_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Iniciar una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operación
  +        """
  +        try:
  +            # Validar requisitos compuestos
  +            can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +            if not can_start:
  +                return {
  +                    'success': False,
  +                    'error': 'requirements_not_met',
  +                    'missing_requirements': missing_reqs
  +                }
  +            
  +            # Verificar si ya existe progreso
  +            existing_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if existing_progress:
  +                if existing_progress.status == 'completed':
  +                    return {
  +                        'success': False,
  +                        'error': 'experience_already_completed'
  +                    }
  +                elif existing_progress.status == 'in_progress':
  +                    return {
  +                        'success': True,
  +                        'status': 'resumed',
  +                        'progress': existing_progress
  +                    }
  +            
  +            # Obtener primer componente
  +            first_component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.experience_id == experience_id,
  +                ExperienceComponent.sequence_order == 1
  +            ).first()
  +            
  +            if not first_component:
  +                return {
  +                    'success': False,
  +                    'error': 'no_components_found'
  +                }
  +            
  +            # Crear progreso de usuario
  +            user_progress = UserExperienceProgress(
  +                user_id=user_id,
  +                experience_id=experience_id,
  +                status='in_progress',
  +                current_component_id=first_component.id,
  +                started_at=datetime.utcnow(),
  ```
  ----------------------------------------------------------
  📍 Línea 273 | @gemini-code-assist[bot]:
  💬 ![high](https://www.gstatic.com/codereviewagent/high-priority.svg)

The formula used to calculate the new `average_completion_time` is incorrect for a running average. This implementation will heavily skew the average towards the most recent completion time.

The correct way to calculate a new running average is:
`new_avg = ((old_avg * (n-1)) + new_value) / n`

Where `n` is the new total number of completions.

```suggestion
                if user_progress.started_at and user_progress.completed_at:
                    completion_time = (user_progress.completed_at - user_progress.started_at).total_seconds() / 60
                    total_completions = experience.completion_count
                    if total_completions == 1:
                        experience.average_completion_time = completion_time
                    else:
                        old_total_time = experience.average_completion_time * (total_completions - 1)
                        new_total_time = old_total_time + completion_time
                        experience.average_completion_time = new_total_time / total_completions
```
  
  Código:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este módulo implementa el motor central para gestionar experiencias que integran
  +múltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def start_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Iniciar una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operación
  +        """
  +        try:
  +            # Validar requisitos compuestos
  +            can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +            if not can_start:
  +                return {
  +                    'success': False,
  +                    'error': 'requirements_not_met',
  +                    'missing_requirements': missing_reqs
  +                }
  +            
  +            # Verificar si ya existe progreso
  +            existing_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if existing_progress:
  +                if existing_progress.status == 'completed':
  +                    return {
  +                        'success': False,
  +                        'error': 'experience_already_completed'
  +                    }
  +                elif existing_progress.status == 'in_progress':
  +                    return {
  +                        'success': True,
  +                        'status': 'resumed',
  +                        'progress': existing_progress
  +                    }
  +            
  +            # Obtener primer componente
  +            first_component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.experience_id == experience_id,
  +                ExperienceComponent.sequence_order == 1
  +            ).first()
  +            
  +            if not first_component:
  +                return {
  +                    'success': False,
  +                    'error': 'no_components_found'
  +                }
  +            
  +            # Crear progreso de usuario
  +            user_progress = UserExperienceProgress(
  +                user_id=user_id,
  +                experience_id=experience_id,
  +                status='in_progress',
  +                current_component_id=first_component.id,
  +                started_at=datetime.utcnow(),
  +                last_activity_at=datetime.utcnow(),
  +                completion_percentage=0.0,
  +                components_completed=0,
  +                components_total=self._get_total_components(experience_id)
  +            )
  +            
  +            self.db.add(user_progress)
  +            self.db.commit()
  +            
  +            # Actualizar contador de inicios
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.start_count += 1
  +                self.db.commit()
  +            
  +            logger.info(f"Experiencia {experience_id} iniciada para usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'status': 'started',
  +                'progress': user_progress,
  +                'current_component': first_component
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al iniciar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def progress_experience(self, user_id: int, experience_id: int, component_id: int, 
  +                          completion_data: Optional[Dict] = None) -> Dict[str, Any]:
  +        """
  +        Progresar en una experiencia marcando un componente como completado
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            component_id: ID del componente completado
  +            completion_data: Datos adicionales de completitud
  +            
  +        Returns:
  +            Dict con resultado de la operación
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress or user_progress.status != 'in_progress':
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_in_progress'
  +                }
  +            
  +            # Verificar que el componente es el actual o está disponible
  +            component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.id == component_id
  +            ).first()
  +            
  +            if not component:
  +                return {
  +                    'success': False,
  +                    'error': 'component_not_found'
  +                }
  +            
  +            # Verificar si ya está completado
  +            existing_completion = self.db.query(UserComponentCompletion).filter(
  +                UserComponentCompletion.user_progress_id == user_progress.id,
  +                UserComponentCompletion.component_id == component_id
  +            ).first()
  +            
  +            if existing_completion:
  +                return {
  +                    'success': False,
  +                    'error': 'component_already_completed'
  +                }
  +            
  +            # Registrar completitud del componente
  +            component_completion = UserComponentCompletion(
  +                user_progress_id=user_progress.id,
  +                component_id=component_id,
  +                completed_at=datetime.utcnow(),
  +                completion_data=completion_data or {}
  +            )
  +            
  +            self.db.add(component_completion)
  +            
  +            # Actualizar progreso
  +            user_progress.components_completed += 1
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Calcular porcentaje de completitud
  +            total_components = user_progress.components_total
  +            if total_components > 0:
  +                user_progress.completion_percentage = (user_progress.components_completed / total_components) * 100
  +            
  +            # Otorgar recompensas del componente
  +            if component.completion_rewards:
  +                self._grant_component_rewards(user_id, component.completion_rewards)
  +            
  +            # Determinar siguiente componente
  +            next_component = self._get_next_component(experience_id, component.sequence_order)
  +            if next_component:
  +                user_progress.current_component_id = next_component.id
  +            else:
  +                # No hay más componentes, completar experiencia
  +                return self.complete_experience(user_id, experience_id)
  +            
  +            self.db.commit()
  +            
  +            logger.info(f"Componente {component_id} completado en experiencia {experience_id} por usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'component_completed': component,
  +                'next_component': next_component,
  +                'progress': user_progress
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al progresar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def complete_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Completar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operación
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress:
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_found'
  +                }
  +            
  +            # Actualizar progreso
  +            user_progress.status = 'completed'
  +            user_progress.completed_at = datetime.utcnow()
  +            user_progress.completion_percentage = 100.0
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Otorgar recompensas finales
  +            experience_rewards = self.db.query(ExperienceReward).filter(
  +                ExperienceReward.experience_id == experience_id
  +            ).all()
  +            
  +            rewards_granted = []
  +            for reward in experience_rewards:
  +                reward_result = self._grant_experience_reward(user_id, reward)
  +                rewards_granted.append({
  +                    'reward': reward,
  +                    'result': reward_result
  +                })
  +            
  +            # Actualizar contador de completitudes
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.completion_count += 1
  +                # Calcular tiempo promedio de completitud
  +                if user_progress.started_at and user_progress.completed_at:
  +                    completion_time = (user_progress.completed_at - user_progress.started_at).total_seconds() / 60
  +                    if experience.average_completion_time == 0:
  +                        experience.average_completion_time = completion_time
  +                    else:
  +                        experience.average_completion_time = (
  +                            experience.average_completion_time + completion_time
  +                        ) / 2
  ```
  ----------------------------------------------------------
  📍 Línea 383 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

This method, along with `_grant_component_rewards` and `_grant_experience_reward`, contains placeholder logic with a `TODO` comment. These should be implemented to provide the actual functionality for checking requirements and granting rewards.
  
  Código:
  ```
  @@ -0,0 +1,406 @@
  +"""
  +Motor de Experiencias Unificadas
  +
  +Este módulo implementa el motor central para gestionar experiencias que integran
  +múltiples elementos de diferentes sistemas en flujos cohesivos.
  +"""
  +
  +from typing import Dict, List, Optional, Any
  +from datetime import datetime
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class ExperienceEngine:
  +    """Motor principal para gestionar experiencias unificadas"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def start_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Iniciar una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operación
  +        """
  +        try:
  +            # Validar requisitos compuestos
  +            can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +            if not can_start:
  +                return {
  +                    'success': False,
  +                    'error': 'requirements_not_met',
  +                    'missing_requirements': missing_reqs
  +                }
  +            
  +            # Verificar si ya existe progreso
  +            existing_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if existing_progress:
  +                if existing_progress.status == 'completed':
  +                    return {
  +                        'success': False,
  +                        'error': 'experience_already_completed'
  +                    }
  +                elif existing_progress.status == 'in_progress':
  +                    return {
  +                        'success': True,
  +                        'status': 'resumed',
  +                        'progress': existing_progress
  +                    }
  +            
  +            # Obtener primer componente
  +            first_component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.experience_id == experience_id,
  +                ExperienceComponent.sequence_order == 1
  +            ).first()
  +            
  +            if not first_component:
  +                return {
  +                    'success': False,
  +                    'error': 'no_components_found'
  +                }
  +            
  +            # Crear progreso de usuario
  +            user_progress = UserExperienceProgress(
  +                user_id=user_id,
  +                experience_id=experience_id,
  +                status='in_progress',
  +                current_component_id=first_component.id,
  +                started_at=datetime.utcnow(),
  +                last_activity_at=datetime.utcnow(),
  +                completion_percentage=0.0,
  +                components_completed=0,
  +                components_total=self._get_total_components(experience_id)
  +            )
  +            
  +            self.db.add(user_progress)
  +            self.db.commit()
  +            
  +            # Actualizar contador de inicios
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.start_count += 1
  +                self.db.commit()
  +            
  +            logger.info(f"Experiencia {experience_id} iniciada para usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'status': 'started',
  +                'progress': user_progress,
  +                'current_component': first_component
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al iniciar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def progress_experience(self, user_id: int, experience_id: int, component_id: int, 
  +                          completion_data: Optional[Dict] = None) -> Dict[str, Any]:
  +        """
  +        Progresar en una experiencia marcando un componente como completado
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            component_id: ID del componente completado
  +            completion_data: Datos adicionales de completitud
  +            
  +        Returns:
  +            Dict con resultado de la operación
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress or user_progress.status != 'in_progress':
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_in_progress'
  +                }
  +            
  +            # Verificar que el componente es el actual o está disponible
  +            component = self.db.query(ExperienceComponent).filter(
  +                ExperienceComponent.id == component_id
  +            ).first()
  +            
  +            if not component:
  +                return {
  +                    'success': False,
  +                    'error': 'component_not_found'
  +                }
  +            
  +            # Verificar si ya está completado
  +            existing_completion = self.db.query(UserComponentCompletion).filter(
  +                UserComponentCompletion.user_progress_id == user_progress.id,
  +                UserComponentCompletion.component_id == component_id
  +            ).first()
  +            
  +            if existing_completion:
  +                return {
  +                    'success': False,
  +                    'error': 'component_already_completed'
  +                }
  +            
  +            # Registrar completitud del componente
  +            component_completion = UserComponentCompletion(
  +                user_progress_id=user_progress.id,
  +                component_id=component_id,
  +                completed_at=datetime.utcnow(),
  +                completion_data=completion_data or {}
  +            )
  +            
  +            self.db.add(component_completion)
  +            
  +            # Actualizar progreso
  +            user_progress.components_completed += 1
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Calcular porcentaje de completitud
  +            total_components = user_progress.components_total
  +            if total_components > 0:
  +                user_progress.completion_percentage = (user_progress.components_completed / total_components) * 100
  +            
  +            # Otorgar recompensas del componente
  +            if component.completion_rewards:
  +                self._grant_component_rewards(user_id, component.completion_rewards)
  +            
  +            # Determinar siguiente componente
  +            next_component = self._get_next_component(experience_id, component.sequence_order)
  +            if next_component:
  +                user_progress.current_component_id = next_component.id
  +            else:
  +                # No hay más componentes, completar experiencia
  +                return self.complete_experience(user_id, experience_id)
  +            
  +            self.db.commit()
  +            
  +            logger.info(f"Componente {component_id} completado en experiencia {experience_id} por usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'component_completed': component,
  +                'next_component': next_component,
  +                'progress': user_progress
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al progresar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def complete_experience(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Completar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con resultado de la operación
  +        """
  +        try:
  +            # Obtener progreso actual
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            if not user_progress:
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_found'
  +                }
  +            
  +            # Actualizar progreso
  +            user_progress.status = 'completed'
  +            user_progress.completed_at = datetime.utcnow()
  +            user_progress.completion_percentage = 100.0
  +            user_progress.last_activity_at = datetime.utcnow()
  +            
  +            # Otorgar recompensas finales
  +            experience_rewards = self.db.query(ExperienceReward).filter(
  +                ExperienceReward.experience_id == experience_id
  +            ).all()
  +            
  +            rewards_granted = []
  +            for reward in experience_rewards:
  +                reward_result = self._grant_experience_reward(user_id, reward)
  +                rewards_granted.append({
  +                    'reward': reward,
  +                    'result': reward_result
  +                })
  +            
  +            # Actualizar contador de completitudes
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            if experience:
  +                experience.completion_count += 1
  +                # Calcular tiempo promedio de completitud
  +                if user_progress.started_at and user_progress.completed_at:
  +                    completion_time = (user_progress.completed_at - user_progress.started_at).total_seconds() / 60
  +                    if experience.average_completion_time == 0:
  +                        experience.average_completion_time = completion_time
  +                    else:
  +                        experience.average_completion_time = (
  +                            experience.average_completion_time + completion_time
  +                        ) / 2
  +            
  +            self.db.commit()
  +            
  +            logger.info(f"Experiencia {experience_id} completada por usuario {user_id}")
  +            
  +            return {
  +                'success': True,
  +                'progress': user_progress,
  +                'rewards_granted': rewards_granted
  +            }
  +            
  +        except Exception as e:
  +            self.db.rollback()
  +            logger.error(f"Error al completar experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def get_experience_status(self, user_id: int, experience_id: int) -> Dict[str, Any]:
  +        """
  +        Obtener estado actual de una experiencia para un usuario
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Dict con estado de la experiencia
  +        """
  +        try:
  +            # Obtener progreso del usuario
  +            user_progress = self.db.query(UserExperienceProgress).filter(
  +                UserExperienceProgress.user_id == user_id,
  +                UserExperienceProgress.experience_id == experience_id
  +            ).first()
  +            
  +            # Obtener experiencia
  +            experience = self.db.query(Experience).filter(Experience.id == experience_id).first()
  +            
  +            if not experience:
  +                return {
  +                    'success': False,
  +                    'error': 'experience_not_found'
  +                }
  +            
  +            # Si no hay progreso, verificar requisitos
  +            if not user_progress:
  +                can_start, missing_reqs = self._validate_requirements(user_id, experience_id)
  +                return {
  +                    'success': True,
  +                    'status': 'not_started',
  +                    'can_start': can_start,
  +                    'missing_requirements': missing_reqs,
  +                    'experience': experience
  +                }
  +            
  +            # Obtener componentes completados
  +            completed_components = self.db.query(UserComponentCompletion).filter(
  +                UserComponentCompletion.user_progress_id == user_progress.id
  +            ).all()
  +            
  +            # Obtener componente actual
  +            current_component = None
  +            if user_progress.current_component_id:
  +                current_component = self.db.query(ExperienceComponent).filter(
  +                    ExperienceComponent.id == user_progress.current_component_id
  +                ).first()
  +            
  +            return {
  +                'success': True,
  +                'status': user_progress.status,
  +                'progress': user_progress,
  +                'current_component': current_component,
  +                'completed_components': completed_components,
  +                'experience': experience
  +            }
  +            
  +        except Exception as e:
  +            logger.error(f"Error al obtener estado de experiencia: {e}")
  +            return {
  +                'success': False,
  +                'error': str(e)
  +            }
  +    
  +    def _validate_requirements(self, user_id: int, experience_id: int) -> tuple[bool, List[Dict]]:
  +        """Validar requisitos compuestos para iniciar experiencia"""
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        all_met = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_requirement(user_id, req)
  +            if not is_met:
  +                all_met = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return all_met, missing_requirements
  +    
  +    def _check_requirement(self, user_id: int, requirement: ExperienceRequirement) -> tuple[bool, Dict]:
  +        """Verificar un requisito específico"""
  +        # TODO: Implementar validación específica por tipo de requisito
  +        # Por ahora retornamos True para todos los requisitos
  +        return True, {}
  ```
  ----------------------------------------------------------

📄 ARCHIVO: modules/experiences/validator.py
============================================================
  📍 Línea 24 | @gemini-code-assist[bot]:
  💬 ![critical](https://www.gstatic.com/codereviewagent/critical.svg)

This line will cause database connection leaks. `get_db()` is a generator that yields a database session and is expected to be used as a dependency in a request-response cycle (like in FastAPI), which ensures the session is closed properly. Calling `next(get_db())` gets a session but never closes it. Over time, this will exhaust the database connection pool.

Instead of initializing `self.db` in the constructor, you should acquire a session within each method that needs database access, or pass the session as an argument.
  
  Código:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este módulo implementa la validación de requisitos que integran múltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  ```
  ----------------------------------------------------------
  📍 Línea 140 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

The methods `_validate_single_requirement` and `_check_experience_requirement` are nearly identical. This code duplication can lead to maintenance issues where a change in one method is not reflected in the other. Consider refactoring to remove the duplication. For example, `_check_experience_requirement` could be adapted to call `_validate_single_requirement`.
  
  Código:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este módulo implementa la validación de requisitos que integran múltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def validate_composite_requirements(self, user_id: int, requirements: List[Dict]) -> Dict[str, Any]:
  +        """
  +        Validar múltiples requisitos de diferentes sistemas
  +        
  +        Args:
  +            user_id: ID del usuario
  +            requirements: Lista de requisitos a validar
  +            
  +        Returns:
  +            Dict con resultado de validación
  +        """
  +        validation_results = []
  +        all_valid = True
  +        
  +        for req in requirements:
  +            is_valid, details = self._validate_single_requirement(user_id, req)
  +            validation_results.append({
  +                'requirement': req,
  +                'is_valid': is_valid,
  +                'details': details
  +            })
  +            
  +            if not is_valid:
  +                all_valid = False
  +        
  +        return {
  +            'all_valid': all_valid,
  +            'validation_results': validation_results
  +        }
  +    
  +    def can_start_experience(self, user_id: int, experience_id: int) -> Tuple[bool, List[Dict]]:
  +        """
  +        Verificar si un usuario puede iniciar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Tuple (puede_iniciar, requisitos_faltantes)
  +        """
  +        # Obtener requisitos de la experiencia
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        can_start = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_experience_requirement(user_id, req)
  +            if not is_met:
  +                can_start = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return can_start, missing_requirements
  +    
  +    def get_missing_requirements(self, user_id: int, experience_id: int) -> List[Dict]:
  +        """
  +        Obtener lista detallada de requisitos faltantes
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Lista de requisitos faltantes con detalles
  +        """
  +        _, missing_reqs = self.can_start_experience(user_id, experience_id)
  +        return missing_reqs
  +    
  +    def _validate_single_requirement(self, user_id: int, requirement: Dict) -> Tuple[bool, Dict]:
  +        """Validar un requisito individual"""
  +        req_type = requirement.get('type')
  +        req_value = requirement.get('value', {})
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _check_experience_requirement(self, user_id: int, requirement: ExperienceRequirement) -> Tuple[bool, Dict]:
  +        """Verificar un requisito de experiencia específico"""
  +        req_type = requirement.requirement_type
  +        req_value = requirement.requirement_value
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  ```
  ----------------------------------------------------------
  📍 Línea 148 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

This method contains placeholder logic with a `TODO` comment and assumes a hardcoded `user_level`. This should be implemented to fetch the actual user level to correctly validate the requirement.
  
  Código:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este módulo implementa la validación de requisitos que integran múltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def validate_composite_requirements(self, user_id: int, requirements: List[Dict]) -> Dict[str, Any]:
  +        """
  +        Validar múltiples requisitos de diferentes sistemas
  +        
  +        Args:
  +            user_id: ID del usuario
  +            requirements: Lista de requisitos a validar
  +            
  +        Returns:
  +            Dict con resultado de validación
  +        """
  +        validation_results = []
  +        all_valid = True
  +        
  +        for req in requirements:
  +            is_valid, details = self._validate_single_requirement(user_id, req)
  +            validation_results.append({
  +                'requirement': req,
  +                'is_valid': is_valid,
  +                'details': details
  +            })
  +            
  +            if not is_valid:
  +                all_valid = False
  +        
  +        return {
  +            'all_valid': all_valid,
  +            'validation_results': validation_results
  +        }
  +    
  +    def can_start_experience(self, user_id: int, experience_id: int) -> Tuple[bool, List[Dict]]:
  +        """
  +        Verificar si un usuario puede iniciar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Tuple (puede_iniciar, requisitos_faltantes)
  +        """
  +        # Obtener requisitos de la experiencia
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        can_start = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_experience_requirement(user_id, req)
  +            if not is_met:
  +                can_start = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return can_start, missing_requirements
  +    
  +    def get_missing_requirements(self, user_id: int, experience_id: int) -> List[Dict]:
  +        """
  +        Obtener lista detallada de requisitos faltantes
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Lista de requisitos faltantes con detalles
  +        """
  +        _, missing_reqs = self.can_start_experience(user_id, experience_id)
  +        return missing_reqs
  +    
  +    def _validate_single_requirement(self, user_id: int, requirement: Dict) -> Tuple[bool, Dict]:
  +        """Validar un requisito individual"""
  +        req_type = requirement.get('type')
  +        req_value = requirement.get('value', {})
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _check_experience_requirement(self, user_id: int, requirement: ExperienceRequirement) -> Tuple[bool, Dict]:
  +        """Verificar un requisito de experiencia específico"""
  +        req_type = requirement.requirement_type
  +        req_value = requirement.requirement_value
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _validate_level_requirement(self, user_id: int, requirement_value: Dict) -> Tuple[bool, Dict]:
  +        """Validar requisito de nivel"""
  +        min_level = requirement_value.get('min_level', 1)
  +        
  +        # TODO: Implementar sistema de niveles
  +        # Por ahora asumimos nivel 1 para todos los usuarios
  +        user_level = 1
  ```
  ----------------------------------------------------------
  📍 Línea 169 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

Using `== True` for boolean comparisons is not idiomatic in Python. It's more concise and conventional to check the truthiness of the value directly.

```suggestion
            VIPSubscription.is_active
```
  
  Código:
  ```
  @@ -0,0 +1,279 @@
  +"""
  +Validador de Requisitos Compuestos
  +
  +Este módulo implementa la validación de requisitos que integran múltiples sistemas
  +para determinar si un usuario puede iniciar o progresar en una experiencia.
  +"""
  +
  +from typing import Dict, List, Optional, Any, Tuple
  +import logging
  +
  +from database.connection import get_db
  +from database.models import (
  +    User, UserBalance, UserInventory, UserAchievement, 
  +    ExperienceRequirement, VIPSubscription
  +)
  +
  +logger = logging.getLogger(__name__)
  +
  +
  +class CompositeValidator:
  +    """Validador de requisitos compuestos"""
  +    
  +    def __init__(self):
  +        self.db = next(get_db())
  +    
  +    def validate_composite_requirements(self, user_id: int, requirements: List[Dict]) -> Dict[str, Any]:
  +        """
  +        Validar múltiples requisitos de diferentes sistemas
  +        
  +        Args:
  +            user_id: ID del usuario
  +            requirements: Lista de requisitos a validar
  +            
  +        Returns:
  +            Dict con resultado de validación
  +        """
  +        validation_results = []
  +        all_valid = True
  +        
  +        for req in requirements:
  +            is_valid, details = self._validate_single_requirement(user_id, req)
  +            validation_results.append({
  +                'requirement': req,
  +                'is_valid': is_valid,
  +                'details': details
  +            })
  +            
  +            if not is_valid:
  +                all_valid = False
  +        
  +        return {
  +            'all_valid': all_valid,
  +            'validation_results': validation_results
  +        }
  +    
  +    def can_start_experience(self, user_id: int, experience_id: int) -> Tuple[bool, List[Dict]]:
  +        """
  +        Verificar si un usuario puede iniciar una experiencia
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Tuple (puede_iniciar, requisitos_faltantes)
  +        """
  +        # Obtener requisitos de la experiencia
  +        requirements = self.db.query(ExperienceRequirement).filter(
  +            ExperienceRequirement.experience_id == experience_id
  +        ).all()
  +        
  +        missing_requirements = []
  +        can_start = True
  +        
  +        for req in requirements:
  +            is_met, details = self._check_experience_requirement(user_id, req)
  +            if not is_met:
  +                can_start = False
  +                missing_requirements.append({
  +                    'requirement': req,
  +                    'details': details
  +                })
  +        
  +        return can_start, missing_requirements
  +    
  +    def get_missing_requirements(self, user_id: int, experience_id: int) -> List[Dict]:
  +        """
  +        Obtener lista detallada de requisitos faltantes
  +        
  +        Args:
  +            user_id: ID del usuario
  +            experience_id: ID de la experiencia
  +            
  +        Returns:
  +            Lista de requisitos faltantes con detalles
  +        """
  +        _, missing_reqs = self.can_start_experience(user_id, experience_id)
  +        return missing_reqs
  +    
  +    def _validate_single_requirement(self, user_id: int, requirement: Dict) -> Tuple[bool, Dict]:
  +        """Validar un requisito individual"""
  +        req_type = requirement.get('type')
  +        req_value = requirement.get('value', {})
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _check_experience_requirement(self, user_id: int, requirement: ExperienceRequirement) -> Tuple[bool, Dict]:
  +        """Verificar un requisito de experiencia específico"""
  +        req_type = requirement.requirement_type
  +        req_value = requirement.requirement_value
  +        
  +        if req_type == 'level':
  +            return self._validate_level_requirement(user_id, req_value)
  +        elif req_type == 'vip_membership':
  +            return self._validate_vip_requirement(user_id, req_value)
  +        elif req_type == 'item':
  +            return self._validate_item_requirement(user_id, req_value)
  +        elif req_type == 'achievement':
  +            return self._validate_achievement_requirement(user_id, req_value)
  +        elif req_type == 'experience_completed':
  +            return self._validate_experience_requirement(user_id, req_value)
  +        elif req_type == 'besitos':
  +            return self._validate_besitos_requirement(user_id, req_value)
  +        else:
  +            logger.warning(f"Tipo de requisito desconocido: {req_type}")
  +            return False, {'error': 'unknown_requirement_type'}
  +    
  +    def _validate_level_requirement(self, user_id: int, requirement_value: Dict) -> Tuple[bool, Dict]:
  +        """Validar requisito de nivel"""
  +        min_level = requirement_value.get('min_level', 1)
  +        
  +        # TODO: Implementar sistema de niveles
  +        # Por ahora asumimos nivel 1 para todos los usuarios
  +        user_level = 1
  +        
  +        is_met = user_level >= min_level
  +        details = {
  +            'required_level': min_level,
  +            'current_level': user_level,
  +            'missing_levels': max(0, min_level - user_level)
  +        }
  +        
  +        return is_met, details
  +    
  +    def _validate_vip_requirement(self, user_id: int, requirement_value: Dict) -> Tuple[bool, Dict]:
  +        """Validar requisito de membresía VIP"""
  +        required = requirement_value.get('required', False)
  +        
  +        if not required:
  +            return True, {'vip_required': False}
  +        
  +        # Verificar suscripción VIP activa
  +        vip_subscription = self.db.query(VIPSubscription).filter(
  +            VIPSubscription.user_id == user_id,
  +            VIPSubscription.is_active == True
  ```
  ----------------------------------------------------------

📄 ARCHIVO: test_experiences_engine.py
============================================================
  📍 Línea 12 | @gemini-code-assist[bot]:
  💬 ![medium](https://www.gstatic.com/codereviewagent/medium-priority.svg)

Modifying `sys.path` at runtime is generally considered a code smell. It can make tests less predictable and dependent on the execution context. It would be better to configure your test runner (like `pytest`) to correctly discover modules by setting the `PYTHONPATH` or using a proper package structure with `__init__.py` files.
  
  Código:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  ```
  ----------------------------------------------------------
  📍 Línea 85 | @gemini-code-assist[bot]:
  💬 ![high](https://www.gstatic.com/codereviewagent/high-priority.svg)

This test is not correctly testing the `can_start_experience` method. You are patching `validate_composite_requirements`, but `can_start_experience` does not call this method. It calls `_check_experience_requirement`. As a result, this test passes without actually validating the intended logic. You should patch `_check_experience_requirement` instead.
  
  Código:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  +
  +# Import experiences modules
  +from modules.experiences.engine import ExperienceEngine
  +from modules.experiences.validator import CompositeValidator
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +
  +class TestCompositeValidator:
  +    """Tests para CompositeValidator"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.validator = CompositeValidator()
  +        self.validator.db = self.mock_db
  +    
  +    def test_validate_composite_requirements_success(self):
  +        """Test que validación de requisitos compuestos funciona correctamente"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 3},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones individuales exitosas
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.return_value = (True, {'message': 'Requirement met'})
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is True
  +            assert len(result['validation_results']) == 3
  +            for validation in result['validation_results']:
  +                assert validation['is_valid'] is True
  +    
  +    def test_validate_composite_requirements_failure(self):
  +        """Test que validación falla cuando faltan requisitos"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 5},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones mixtas (algunas fallan)
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.side_effect = [
  +                (False, {'message': 'Level too low'}),
  +                (True, {'message': 'VIP requirement met'}),
  +                (False, {'message': 'Not enough besitos'})
  +            ]
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is False
  +            assert len(result['validation_results']) == 3
  +            assert result['validation_results'][0]['is_valid'] is False
  +            assert result['validation_results'][1]['is_valid'] is True
  +            assert result['validation_results'][2]['is_valid'] is False
  +    
  +    def test_can_start_experience_success(self):
  +        """Test que verifica si usuario puede iniciar experiencia exitosamente"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  ```
  ----------------------------------------------------------
  📍 Línea 147 | @gemini-code-assist[bot]:
  💬 ![high](https://www.gstatic.com/codereviewagent/high-priority.svg)

This assertion is incorrect. The `start_experience` method in `ExperienceEngine` calls `self.db.commit()` twice under successful conditions (once after adding `user_progress`, and once after updating `experience.start_count`). This test will fail. The assertion should be changed to `assert_has_calls` or the number of expected calls should be corrected.

```suggestion
            self.mock_db.commit.call_count == 2
```
  
  Código:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  +
  +# Import experiences modules
  +from modules.experiences.engine import ExperienceEngine
  +from modules.experiences.validator import CompositeValidator
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +
  +class TestCompositeValidator:
  +    """Tests para CompositeValidator"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.validator = CompositeValidator()
  +        self.validator.db = self.mock_db
  +    
  +    def test_validate_composite_requirements_success(self):
  +        """Test que validación de requisitos compuestos funciona correctamente"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 3},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones individuales exitosas
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.return_value = (True, {'message': 'Requirement met'})
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is True
  +            assert len(result['validation_results']) == 3
  +            for validation in result['validation_results']:
  +                assert validation['is_valid'] is True
  +    
  +    def test_validate_composite_requirements_failure(self):
  +        """Test que validación falla cuando faltan requisitos"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 5},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones mixtas (algunas fallan)
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.side_effect = [
  +                (False, {'message': 'Level too low'}),
  +                (True, {'message': 'VIP requirement met'}),
  +                (False, {'message': 'Not enough besitos'})
  +            ]
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is False
  +            assert len(result['validation_results']) == 3
  +            assert result['validation_results'][0]['is_valid'] is False
  +            assert result['validation_results'][1]['is_valid'] is True
  +            assert result['validation_results'][2]['is_valid'] is False
  +    
  +    def test_can_start_experience_success(self):
  +        """Test que verifica si usuario puede iniciar experiencia exitosamente"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {'all_valid': True, 'validation_results': []}
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is True
  +            assert len(missing_reqs) == 0
  +    
  +    def test_can_start_experience_failure(self):
  +        """Test que verifica si usuario NO puede iniciar experiencia"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {
  +                'all_valid': False, 
  +                'validation_results': [
  +                    {'requirement': {'type': 'level'}, 'is_valid': False, 'details': {'message': 'Level too low'}}
  +                ]
  +            }
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is False
  +            assert len(missing_reqs) == 1
  +            assert missing_reqs[0]['type'] == 'level'
  +
  +
  +class TestExperienceEngine:
  +    """Tests para ExperienceEngine"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.engine = ExperienceEngine()
  +        self.engine.db = self.mock_db
  +    
  +    def test_start_experience_success(self):
  +        """Test que se puede iniciar una experiencia exitosamente"""
  +        # Mock de validación exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de que no existe progreso previo
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = None
  +            
  +            # Mock de primer componente
  +            mock_component = Mock()
  +            mock_component.id = 1
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_component
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is True
  +            assert result['status'] == 'started'
  +            assert 'progress' in result
  +            
  +            # Verificar que se guardó en la base de datos
  +            self.mock_db.add.assert_called_once()
  +            self.mock_db.commit.assert_called_once()
  ```
  ----------------------------------------------------------
  📍 Línea 280 | @gemini-code-assist[bot]:
  💬 ![critical](https://www.gstatic.com/codereviewagent/critical.svg)

These tests (`test_complete_component_success` and `test_complete_component_final_component`) are attempting to test a method named `complete_component` which does not exist in the `ExperienceEngine` class. The method for advancing an experience is `progress_experience`. These tests need to be rewritten to target the correct method and use the appropriate arguments and mocks. As they are, they provide no test coverage for the progression logic.
  
  Código:
  ```
  @@ -0,0 +1,283 @@
  +"""
  +Tests unitarios para el motor de experiencias unificadas
  +"""
  +
  +import pytest
  +from unittest.mock import Mock, patch, MagicMock
  +from datetime import datetime
  +import sys
  +import os
  +
  +# Add modules to path
  +sys.path.insert(0, os.path.join(os.path.dirname(__file__), '.'))
  +
  +# Import experiences modules
  +from modules.experiences.engine import ExperienceEngine
  +from modules.experiences.validator import CompositeValidator
  +from database.models import (
  +    Experience, ExperienceComponent, UserExperienceProgress, 
  +    UserComponentCompletion, ExperienceRequirement, ExperienceReward
  +)
  +
  +
  +class TestCompositeValidator:
  +    """Tests para CompositeValidator"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.validator = CompositeValidator()
  +        self.validator.db = self.mock_db
  +    
  +    def test_validate_composite_requirements_success(self):
  +        """Test que validación de requisitos compuestos funciona correctamente"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 3},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones individuales exitosas
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.return_value = (True, {'message': 'Requirement met'})
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is True
  +            assert len(result['validation_results']) == 3
  +            for validation in result['validation_results']:
  +                assert validation['is_valid'] is True
  +    
  +    def test_validate_composite_requirements_failure(self):
  +        """Test que validación falla cuando faltan requisitos"""
  +        # Mock de requisitos
  +        mock_requirements = [
  +            {'type': 'level', 'min_level': 5},
  +            {'type': 'vip_membership', 'required': True},
  +            {'type': 'besitos', 'min_amount': 500}
  +        ]
  +        
  +        # Mock de validaciones mixtas (algunas fallan)
  +        with patch.object(self.validator, '_validate_single_requirement') as mock_validate:
  +            mock_validate.side_effect = [
  +                (False, {'message': 'Level too low'}),
  +                (True, {'message': 'VIP requirement met'}),
  +                (False, {'message': 'Not enough besitos'})
  +            ]
  +            
  +            result = self.validator.validate_composite_requirements(1, mock_requirements)
  +            
  +            assert result['all_valid'] is False
  +            assert len(result['validation_results']) == 3
  +            assert result['validation_results'][0]['is_valid'] is False
  +            assert result['validation_results'][1]['is_valid'] is True
  +            assert result['validation_results'][2]['is_valid'] is False
  +    
  +    def test_can_start_experience_success(self):
  +        """Test que verifica si usuario puede iniciar experiencia exitosamente"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {'all_valid': True, 'validation_results': []}
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is True
  +            assert len(missing_reqs) == 0
  +    
  +    def test_can_start_experience_failure(self):
  +        """Test que verifica si usuario NO puede iniciar experiencia"""
  +        # Mock de requisitos de experiencia
  +        mock_requirements = [Mock()]
  +        
  +        # Configurar mocks
  +        self.mock_db.query.return_value.filter.return_value.all.return_value = mock_requirements
  +        
  +        with patch.object(self.validator, 'validate_composite_requirements') as mock_validate:
  +            mock_validate.return_value = {
  +                'all_valid': False, 
  +                'validation_results': [
  +                    {'requirement': {'type': 'level'}, 'is_valid': False, 'details': {'message': 'Level too low'}}
  +                ]
  +            }
  +            
  +            can_start, missing_reqs = self.validator.can_start_experience(1, 1)
  +            
  +            assert can_start is False
  +            assert len(missing_reqs) == 1
  +            assert missing_reqs[0]['type'] == 'level'
  +
  +
  +class TestExperienceEngine:
  +    """Tests para ExperienceEngine"""
  +    
  +    def setup_method(self):
  +        """Setup para cada test"""
  +        self.mock_db = Mock()
  +        self.engine = ExperienceEngine()
  +        self.engine.db = self.mock_db
  +    
  +    def test_start_experience_success(self):
  +        """Test que se puede iniciar una experiencia exitosamente"""
  +        # Mock de validación exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de que no existe progreso previo
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = None
  +            
  +            # Mock de primer componente
  +            mock_component = Mock()
  +            mock_component.id = 1
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_component
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is True
  +            assert result['status'] == 'started'
  +            assert 'progress' in result
  +            
  +            # Verificar que se guardó en la base de datos
  +            self.mock_db.add.assert_called_once()
  +            self.mock_db.commit.assert_called_once()
  +    
  +    def test_start_experience_requirements_failed(self):
  +        """Test que no se puede iniciar experiencia sin requisitos"""
  +        # Mock de validación fallida
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (False, ['level_5'])
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is False
  +            assert result['error'] == 'requirements_not_met'
  +            assert 'level_5' in result['missing_requirements']
  +            
  +            # Verificar que NO se guardó en la base de datos
  +            self.mock_db.add.assert_not_called()
  +            self.mock_db.commit.assert_not_called()
  +    
  +    def test_start_experience_already_completed(self):
  +        """Test que no se puede reiniciar experiencia completada"""
  +        # Mock de validación exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de progreso ya completado
  +            mock_progress = Mock()
  +            mock_progress.status = 'completed'
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_progress
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is False
  +            assert result['error'] == 'experience_already_completed'
  +    
  +    def test_start_experience_resume(self):
  +        """Test que se puede reanudar experiencia en progreso"""
  +        # Mock de validación exitosa
  +        with patch.object(self.engine, '_validate_requirements') as mock_validate:
  +            mock_validate.return_value = (True, [])
  +            
  +            # Mock de progreso en progreso
  +            mock_progress = Mock()
  +            mock_progress.status = 'in_progress'
  +            self.mock_db.query.return_value.filter.return_value.first.return_value = mock_progress
  +            
  +            result = self.engine.start_experience(1, 1)
  +            
  +            assert result['success'] is True
  +            assert result['status'] == 'resumed'
  +            assert result['progress'] == mock_progress
  +    
  +    def test_complete_component_success(self):
  +        """Test que se puede completar un componente"""
  +        # Mock de progreso
  +        mock_progress = Mock()
  +        mock_progress.user_id = 1
  +        mock_progress.experience_id = 1
  +        mock_progress.components_completed = 0
  +        mock_progress.components_total = 3
  +        mock_progress.completion_percentage = 0.0
  +        
  +        # Mock de componente
  +        mock_component = Mock()
  +        mock_component.id = 1
  +        mock_component.sequence_order = 1
  +        mock_component.completion_rewards = {'besitos': 25}
  +        
  +        # Mock de experiencia
  +        mock_experience = Mock()
  +        mock_experience.components = [mock_component, Mock(), Mock()]
  +        
  +        # Mock de siguiente componente
  +        with patch.object(self.engine, '_get_next_component') as mock_next:
  +            mock_next.return_value = Mock()
  +            
  +            result = self.engine.complete_component(mock_progress, mock_component, mock_experience)
  +            
  +            assert result['success'] is True
  +            assert 'completion' in result
  +            assert 'rewards_granted' in result
  +            assert result['rewards_granted']['besitos'] == 25
  +            
  +            # Verificar que se actualizó el progreso
  +            assert mock_progress.components_completed == 1
  +            assert mock_progress.completion_percentage == 33.33
  +            assert mock_progress.last_activity_at is not None
  +            
  +            # Verificar que se guardó en la base de datos
  +            self.mock_db.add.assert_called_once()
  +            self.mock_db.commit.assert_called_once()
  +    
  +    def test_complete_component_final_component(self):
  +        """Test que completar último componente completa la experiencia"""
  +        # Mock de progreso
  +        mock_progress = Mock()
  +        mock_progress.user_id = 1
  +        mock_progress.experience_id = 1
  +        mock_progress.components_completed = 2
  +        mock_progress.components_total = 3
  +        mock_progress.completion_percentage = 66.67
  +        
  +        # Mock de componente
  +        mock_component = Mock()
  +        mock_component.id = 3
  +        mock_component.sequence_order = 3
  +        mock_component.completion_rewards = {'besitos': 50}
  +        
  +        # Mock de experiencia
  +        mock_experience = Mock()
  +        mock_experience.id = 1
  +        mock_experience.completion_count = 0
  +        mock_experience.rewards = [Mock(reward_type='besitos', reward_value={'amount': 100})]
  +        
  +        # Mock de que no hay siguiente componente
  +        with patch.object(self.engine, '_get_next_component') as mock_next:
  +            mock_next.return_value = None
  +            
  +            # Mock de recompensas de experiencia
  +            with patch.object(self.engine, '_grant_experience_rewards') as mock_grant:
  +                mock_grant.return_value = {'besitos': 100}
  +                
  +                result = self.engine.complete_component(mock_progress, mock_component, mock_experience)
  +                
  +                assert result['success'] is True
  +                assert 'experience_completed' in result
  +                assert result['experience_completed'] is True
  +                
  +                # Verificar que se actualizó el progreso a completado
  +                assert mock_progress.status == 'completed'
  +                assert mock_progress.completed_at is not None
  +                
  +                # Verificar que se actualizó la experiencia
  +                assert mock_experience.completion_count == 1
  +
  ```
  ----------------------------------------------------------


============================================================
RESUMEN:
------------------------------------------------------------
  📝 Comentarios en conversación: 1
  ⭐ Reviews generales: 1
  📄 Comentarios en código: 14
============================================================
